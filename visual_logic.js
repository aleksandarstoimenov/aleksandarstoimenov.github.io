/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.5.1
 * Sun, 18 Feb 2024 21:14:41 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'block', 'start-button', true);
  setHTMLElemStyle('display', 'block', 'start-button-hovered', true);
})();
};

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["Play zoom out animation"] = Play_zoom_out_animation;
this.procedures["Update the text in the Pop up"] = Update_the_text_in_the_Pop_up;
this.procedures["Zoom to clicked room"] = Zoom_to_clicked_room;
this.procedures["Outline hovered object"] = Outline_hovered_object;
this.procedures["set_room_animation_frame_timer"] = set_room_animation_frame_timer;
this.procedures["Hoover over room animation"] = Hoover_over_room_animation;

var animations_except_garden, furniture_triggers, room_animation_triggers, What_is_the_current_camera_, Which_animation_to_play___all_rooms___the_current_one_, Is_there_a_wall___zoom_out_, object_clicked, paragraph_text, Which_room_trigger_, Which_animation_to_play___all_the_rooms___current_one_, Which_room_does_the_camera_look_to_, Empty_to_move_the_camera_to_, Camera_selector_zoom_in, Is_there_a_wall___zoom_in_, Which_room_to_reverse_hover_animation_, Outline_trigger_, Outline_object_, room_animation_duration, rooms_disapearing_duration, zoomed_in, camera_animation_duration, Which_room_is_hoovered_, Which_room_to_trigger_hoover_animation_, animations_except_study_room, room_animation_frame, animations_except_living_room, animations_except_boiler_room, current_camera, animations_except_entrance, animations_except_kitchen, animations_except_bedroom, animations_except_bathroom, animations_except_toilet;

// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    if (appInstance.scene) {
        appInstance.scene.traverse(function(obj) {
            if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
                objFound = obj;
                if (runTime) {
                    _pGlob.objCache[objName] = objFound;
                }
            }
        });
    }
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}

// getAnimations puzzle
function getAnimations(objSelector) {
    const objNames = retrieveObjectNames(objSelector);

    const animations = [];
    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i];
        if (!objName)
            continue;
        // use objName as animName - for now we have one-to-one match
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, objName);
        if (action)
            animations.push(objName);
    }
    return animations;
}

/**
 * Get a scene that contains the root of the given action.
 */
function getSceneByAction(action) {
    var root = action.getRoot();
    var scene = root.type == "Scene" ? root : null;
    root.traverseAncestors(function(ancObj) {
        if (ancObj.type == "Scene") {
            scene = ancObj;
        }
    });
    return scene;
}

/**
 * Get the current scene's framerate.
 */
function getSceneAnimFrameRate(scene) {
    if (scene && 'animFrameRate' in scene.userData) {
        return scene.userData.animFrameRate;
    }
    return 24;
}

function _checkListenersSame(target0, type0, listener0, optionsOrUseCapture0,
        target1, type1, listener1, optionsOrUseCapture1) {
    const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
            ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
    const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
            ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
    return target0 === target1 && type0 === type1 && listener0 === listener1
            && capture0 === capture1;
}

/**
 * Add the specified event listener to the specified target. This function also
 * stores listener data for easier disposing.
 */
function bindListener(target, type, listener, optionsOrUseCapture) {
    const alreadyExists = _pGlob.eventListeners.some(elem => {
        return _checkListenersSame(elem.target, elem.type, elem.listener,
                elem.optionsOrUseCapture, target, type, listener,
                optionsOrUseCapture);
    });

    if (!alreadyExists) {
        target.addEventListener(type, listener, optionsOrUseCapture);
        _pGlob.eventListeners.push({ target, type, listener, optionsOrUseCapture });
    }
}

_pGlob.animMixerCallbacks = [];

var initAnimationMixer = function() {

    function onMixerFinished(e) {
        var cb = _pGlob.animMixerCallbacks;
        var found = [];
        for (var i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (var i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;
        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();
                if (loop && (loop != "AUTO"))
                    action.loop = v3d[loop];
                var scene = getSceneByAction(action);
                var frameRate = getSceneAnimFrameRate(scene);

                action.repetitions = Infinity;

                var timeScale = Math.abs(parseFloat(speed));
                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                var callbacks = _pGlob.animMixerCallbacks;
                var found = false;

                for (var j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            var callbacks = _pGlob.animMixerCallbacks;
            for (var j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            var scene = getSceneByAction(action);
            var frameRate = getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            var timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// getAnimationFrame puzzle
function getAnimationFrame(animName) {
    if (!animName)
        return;
    var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
    if (action) {
        var scene = getSceneByAction(action);
        var frameRate = getSceneAnimFrameRate(scene);
        return action.time * frameRate;
    } else {
        return;
    }
}

// isAnimationPlaying puzzle
function isAnimationPlaying(animations) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];
    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (!animName)
            continue;
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (action && action.isRunning())
            return true;
    }
    return false;
}

// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

    var elem = appInstance.renderer.domElement;
    bindListener(elem, eventType, pickListener);

    if (eventType == 'mousedown') {

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        bindListener(elem, touchEventName, pickListener);

    } else if (eventType == 'dblclick') {

        var prevTapTime = 0;

        function doubleTapCallback(event) {

            var now = new Date().getTime();
            var timesince = now - prevTapTime;

            if (timesince < 600 && timesince > 0) {

                pickListener(event);
                prevTapTime = 0;
                return;

            }

            prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        bindListener(elem, touchEventName, doubleTapCallback);
    }

    var raycaster = new v3d.Raycaster();

    function pickListener(event) {

        // to handle unload in loadScene puzzle
        if (!appInstance.getCamera())
            return;

        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            if (mouseButtons && mouseButtons.indexOf(event.button) == -1)
                return;
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList, false);
        callback(intersects, event);
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);
            var objNames = retrieveObjectNames(objSelector);

            if (objectsIncludeObj(objNames, objName)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}

// getEntityByName puzzle
function getEntityByName(name, getWhat) {
    switch (getWhat) {
        case 'OBJECT':
        case 'ANIMATION':
        case 'MATERIAL':
            return name;
        case 'GROUP':
            return ['GROUP', name];
    }
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

function matGetColors(matName) {
    var mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return [];

    if (mat.isMeshNodeMaterial)
        return Object.keys(mat.nodeRGBMap);
    else if (mat.isMeshStandardMaterial)
        return ['color', 'emissive'];
    else
        return [];
}

// setMaterialColor puzzle
function setMaterialColor(matName, colName, r, g, b, cssCode) {

    var colors = matGetColors(matName);

    if (colors.indexOf(colName) < 0)
        return;

    if (cssCode) {
        var color = new v3d.Color(cssCode);
        r = color.r;
        g = color.g;
        b = color.b;
    }

    var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    for (var i = 0; i < mats.length; i++) {
        var mat = mats[i];

        if (mat.isMeshNodeMaterial) {
            var rgbIdx = mat.nodeRGBMap[colName];
            mat.nodeRGB[rgbIdx].x = r;
            mat.nodeRGB[rgbIdx].y = g;
            mat.nodeRGB[rgbIdx].z = b;
        } else {
            mat[colName].r = r;
            mat[colName].g = g;
            mat[colName].b = b;
        }
        mat.needsUpdate = true;

        if (appInstance.scene !== null) {
            if (mat === appInstance.scene.worldMaterial) {
                appInstance.updateEnvironment(mat);
            }
        }
    }
}

// Copyright (c) 2010-2019 Tween.js authors.
// Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
// Code copied from https://cdnjs.cloudflare.com/ajax/libs/tween.js/17.3.0/Tween.min.js

var _Group=function(){this._tweens={},this._tweensAddedDuringUpdate={}};_Group.prototype={getAll:function(){return Object.keys(this._tweens).map(function(t){return this._tweens[t]}.bind(this))},removeAll:function(){this._tweens={}},add:function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},remove:function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},update:function(t,n){var e=Object.keys(this._tweens);
if(0===e.length)return!1;for(t=void 0!==t?t:TWEEN.now();0<e.length;){this._tweensAddedDuringUpdate={};for(var i=0;i<e.length;i++){var r=this._tweens[e[i]];r&&!1===r.update(t)&&(r._isPlaying=!1,n||delete this._tweens[e[i]])}e=Object.keys(this._tweensAddedDuringUpdate)}return!0}};var TWEEN=new _Group;TWEEN.Group=_Group,TWEEN._nextId=0,TWEEN.nextId=function(){return TWEEN._nextId++},"undefined"==typeof window&&"undefined"!=typeof process&&process.hrtime?TWEEN.now=function(){var t=process.hrtime();
return 1e3*t[0]+t[1]/1e6}:"undefined"!=typeof window&&void 0!==window.performance&&void 0!==window.performance.now?TWEEN.now=window.performance.now.bind(window.performance):void 0!==Date.now?TWEEN.now=Date.now:TWEEN.now=function(){return(new Date).getTime()},TWEEN.Tween=function(t,n){this._object=t,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._repeat=0,this._repeatDelayTime=void 0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,
this._startTime=null,this._easingFunction=TWEEN.Easing.Linear.None,this._interpolationFunction=TWEEN.Interpolation.Linear,this._chainedTweens=[],this._onStartCallback=null,this._onStartCallbackFired=!1,this._onUpdateCallback=null,this._onCompleteCallback=null,this._onStopCallback=null,this._group=n||TWEEN,this._id=TWEEN.nextId()},TWEEN.Tween.prototype={getId:function(){return this._id},isPlaying:function(){return this._isPlaying},to:function(t,n){return this._valuesEnd=t,void 0!==n&&(this._duration=n),this},start:function(t){for(var n in this._group.add(this),this._isPlaying=!0,this._onStartCallbackFired=!1,this._startTime=void 0!==t?"string"==typeof t?TWEEN.now()+parseFloat(t):t:TWEEN.now(),this._startTime+=this._delayTime,this._valuesEnd){if(this._valuesEnd[n]instanceof Array){if(0===this._valuesEnd[n].length)continue;
this._valuesEnd[n]=[this._object[n]].concat(this._valuesEnd[n])}void 0!==this._object[n]&&(this._valuesStart[n]=this._object[n],this._valuesStart[n]instanceof Array==!1&&(this._valuesStart[n]*=1),this._valuesStartRepeat[n]=this._valuesStart[n]||0)}return this},stop:function(){return this._isPlaying&&(this._group.remove(this),this._isPlaying=!1,null!==this._onStopCallback&&this._onStopCallback(this._object),this.stopChainedTweens()),this},end:function(){return this.update(this._startTime+this._duration),this},stopChainedTweens:function(){for(var t=0,n=this._chainedTweens.length;t<n;
t++)this._chainedTweens[t].stop()},group:function(t){return this._group=t,this},delay:function(t){return this._delayTime=t,this},repeat:function(t){return this._repeat=t,this},repeatDelay:function(t){return this._repeatDelayTime=t,this},yoyo:function(t){return this._yoyo=t,this},easing:function(t){return this._easingFunction=t,this},interpolation:function(t){return this._interpolationFunction=t,this},chain:function(){return this._chainedTweens=arguments,this},onStart:function(t){return this._onStartCallback=t,this},onUpdate:function(t){return this._onUpdateCallback=t,this},onComplete:function(t){return this._onCompleteCallback=t,this},onStop:function(t){return this._onStopCallback=t,this},update:function(t){var n,e,i;if(t<this._startTime)return!0;
for(n in!1===this._onStartCallbackFired&&(null!==this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),e=(t-this._startTime)/this._duration,e=0===this._duration||1<e?1:e,i=this._easingFunction(e),this._valuesEnd)if(void 0!==this._valuesStart[n]){var r=this._valuesStart[n]||0,a=this._valuesEnd[n];a instanceof Array?this._object[n]=this._interpolationFunction(a,i):("string"==typeof a&&(a="+"===a.charAt(0)||"-"===a.charAt(0)?r+parseFloat(a):parseFloat(a)),"number"==typeof a&&(this._object[n]=r+(a-r)*i))}if(null!==this._onUpdateCallback&&this._onUpdateCallback(this._object),1!==e)return!0;
if(0<this._repeat){for(n in isFinite(this._repeat)&&this._repeat--,this._valuesStartRepeat){if("string"==typeof this._valuesEnd[n]&&(this._valuesStartRepeat[n]=this._valuesStartRepeat[n]+parseFloat(this._valuesEnd[n])),this._yoyo){var s=this._valuesStartRepeat[n];this._valuesStartRepeat[n]=this._valuesEnd[n],this._valuesEnd[n]=s}this._valuesStart[n]=this._valuesStartRepeat[n]}return this._yoyo&&(this._reversed=!this._reversed),void 0!==this._repeatDelayTime?this._startTime=t+this._repeatDelayTime:this._startTime=t+this._delayTime,!0}null!==this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var o=0,u=this._chainedTweens.length;o<u;o++)this._chainedTweens[o].start(this._startTime+this._duration);
return!1}},TWEEN.Easing={Linear:{None:function(t){return t}},Quadratic:{In:function(t){return t*t},Out:function(t){return t*(2-t)},InOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}},Cubic:{In:function(t){return t*t*t},Out:function(t){return--t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}},Quartic:{In:function(t){return t*t*t*t},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}},Quintic:{In:function(t){return t*t*t*t*t},Out:function(t){return--t*t*t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}},Sinusoidal:{In:function(t){return 1-Math.cos(t*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return.5*(1-Math.cos(Math.PI*t))}},Exponential:{In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},
InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}},Circular:{In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}},Elastic:{In:function(t){return 0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)},Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin(5*(t-.1)*Math.PI)+1},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?-.5*Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI):.5*Math.pow(2,-10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)+1}},Back:{In:function(t){return t*t*(2.70158*t-1.70158)},Out:function(t){return--t*t*(2.70158*t+1.70158)+1},InOut:function(t){var n=2.5949095;
return(t*=2)<1?t*t*((n+1)*t-n)*.5:.5*((t-=2)*t*((n+1)*t+n)+2)}},Bounce:{In:function(t){return 1-TWEEN.Easing.Bounce.Out(1-t)},Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},InOut:function(t){return t<.5?.5*TWEEN.Easing.Bounce.In(2*t):.5*TWEEN.Easing.Bounce.Out(2*t-1)+.5}}},TWEEN.Interpolation={Linear:function(t,n){var e=t.length-1,i=e*n,r=Math.floor(i),a=TWEEN.Interpolation.Utils.Linear;return n<0?a(t[0],t[1],i):1<n?a(t[e],t[e-1],e-i):a(t[r],t[e<r+1?e:r+1],i-r)},Bezier:function(t,n){for(var e=0,i=t.length-1,r=Math.pow,a=TWEEN.Interpolation.Utils.Bernstein,s=0;s<=i;s++)e+=r(1-n,i-s)*r(n,s)*t[s]*a(i,s);return e},CatmullRom:function(t,n){var e=t.length-1,i=e*n,r=Math.floor(i),a=TWEEN.Interpolation.Utils.CatmullRom;
return t[0]===t[e]?(n<0&&(r=Math.floor(i=e*(1+n))),a(t[(r-1+e)%e],t[r],t[(r+1)%e],t[(r+2)%e],i-r)):n<0?t[0]-(a(t[0],t[0],t[1],t[1],-i)-t[0]):1<n?t[e]-(a(t[e],t[e],t[e-1],t[e-1],i-e)-t[e]):a(t[r?r-1:0],t[r],t[e<r+1?e:r+1],t[e<r+2?e:r+2],i-r)},Utils:{Linear:function(t,n,e){return(n-t)*e+t},Bernstein:function(t,n){var e=TWEEN.Interpolation.Utils.Factorial;return e(t)/e(n)/e(t-n)},Factorial:function(){var i=[1];return function(t){var n=1;if(i[t])return i[t];for(var e=t;1<e;e--)n*=e;return i[t]=n}}(),CatmullRom:function(t,n,e,i,r){var a=.5*(e-t),s=.5*(i-n),o=r*r;return(2*n-2*e+a+s)*(r*o)+(-3*n+3*e-2*a-s)*o+a*r+n}}},function(t){"function"==typeof define&&define.amd?define([],function(){return TWEEN}):"undefined"!=typeof module&&"object"==typeof exports?module.exports=TWEEN:void 0!==t&&(t.TWEEN=TWEEN)}(this);

// animateParam puzzle
function tweenUpdateCb() {
    TWEEN.update();
}
appInstance.renderCallbacks.push(tweenUpdateCb);
if (PL.editorRenderCallbacks)
    PL.editorRenderCallbacks.push([appInstance, tweenUpdateCb]);

// animateParam puzzle
_pGlob.animateParamUpdate = 0;
_pGlob.animateParamTweenInstance = {};

function animateParam(from, to, duration, easing, easing2, repeat, yoyo, blockId, on_update, when_finished) {

    var mode = easing == "Linear" ?
        TWEEN.Easing.Linear.None : TWEEN.Easing[easing][easing2];

    var tweenObject = (typeof from != "number");

    if (!tweenObject) { // number
        from = [from];
        to = [to];
    }

    const tween = new TWEEN.Tween(from)
                    .to(to, duration * 1000)
                    .easing(mode)
                    .repeat(repeat)
                    .yoyo(yoyo)
                    .onUpdate(function (object) {
                        if (tweenObject)
                            _pGlob.animateParamUpdate = object;
                        else // number
                            _pGlob.animateParamUpdate = object[0];
                        on_update();
                    })
                    .onComplete(function (object) {
                        when_finished();
                    })
                    .start();

    _pGlob.animateParamTweenInstance[blockId] = tween;
}

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('setCameraParam: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controls) {
                console.error('setCameraParam: The "' + camName +'" camera has no controller');
                return;
            } else if ((isSetOrbitParam && cam.controls.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controls.type != 'FIRST_PERSON')) {
                console.error('setCameraParam: Incompatible camera controller: ' + cam.controls.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controls.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controls.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controls.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controls.enableZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controls.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controls.orbitMinDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controls.orbitMaxDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controls.orbitMinZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controls.orbitMaxZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controls.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controls.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controls.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controls.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controls.orbitEnableTurnover = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controls.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && 'coordSystem' in scene.userData) {
        return scene.userData.coordSystem;
    }

    return 'Y_UP_RIGHT';
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
const eulerV3DToBlenderShortest = function() {

    const eulerTmp = new v3d.Euler();
    const eulerTmp2 = new v3d.Euler();
    const vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
        const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = coordsTransform(worldPos, getCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = coordsTransform(worldTarget, getCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// Describe this function...
function Play_zoom_out_animation(What_is_the_current_camera_, Which_animation_to_play___all_rooms___the_current_one_, Is_there_a_wall___zoom_out_) {
  registerOnClick('background', true, true, [0,1,2], function() {
    if (zoomed_in == true && current_camera == What_is_the_current_camera_) {
      changeVis(getEntityByName(furniture_triggers, 'OBJECT'), false);
      setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 180);
      tweenCamera('camera_position_original', 'camera_target_origin', 0.8, function() {
        zoomed_in = false;
        changeVis(room_animation_triggers, true);
        setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 100);
      }, 0);

      operateAnimation('PLAY', getAnimations(Which_animation_to_play___all_rooms___the_current_one_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
              function() {}, true);


      operateAnimation('PLAY', getAnimations(Is_there_a_wall___zoom_out_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
              function() {}, true);

          }
  }, function() {});
}

// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// whenHovered puzzle
initObjectPicking(function(intersects, event) {

    var prevHovered = _pGlob.hoveredObject;
    var currHovered = '';

    // the event might happen before hover registration
    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    // search for closest hovered object

    var lastIntersectIndex = Infinity;
    _pGlob.objHoverInfo.forEach(function(el) {
        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (objectsIncludeObj(retrieveObjectNames(el.objSelector), objName) && i <= lastIntersectIndex) {
                currHovered = objName;
                lastIntersectIndex = i;
            }
        }
    });

    if (prevHovered == currHovered) return;

    // first - all "out" callbacks, then - all "over"
    _pGlob.objHoverInfo.forEach(function(el) {
        if (objectsIncludeObj(retrieveObjectNames(el.objSelector), prevHovered)) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1](event);
        }
    });

    _pGlob.objHoverInfo.forEach(function(el) {
        if (objectsIncludeObj(retrieveObjectNames(el.objSelector), currHovered)) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0](event);
        }
    });

    _pGlob.hoveredObject = currHovered;
}, 'mousemove', false);

// whenHovered puzzle
function registerOnHover(objSelector, xRay, cbOver, cbOut) {

    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    _pGlob.objHoverInfo.push({
        objSelector: objSelector,
        callbacks: [cbOver, cbOut],
        xRay: xRay
    });
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// Describe this function...
function Update_the_text_in_the_Pop_up(object_clicked, paragraph_text) {
  registerOnHover(object_clicked, false, function() {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);
  }, function() {
    setHTMLElemStyle('cursor', 'default', ['BODY'], false);
  });
  registerOnClick(object_clicked, false, false, [0,1,2], function() {
    setHTMLElemStyle('transform', 'translate(-50%, -50%)', 'text-container-phone', true);
    setHTMLElemAttribute('innerHTML', paragraph_text, 'text-block-phone', true);
    setHTMLElemStyle('transform', 'translate(300%, -50%)', 'text-block', true);
    registerSetTimeout(0.4, function() {
      setHTMLElemAttribute('innerHTML', paragraph_text, 'text-block', true);
      setHTMLElemStyle('transform', 'translate(-50%, -50%)', 'text-block', true);
    });
  }, function() {});
}

// Describe this function...
function Zoom_to_clicked_room(Which_room_trigger_, Which_animation_to_play___all_the_rooms___current_one_, Which_room_does_the_camera_look_to_, Empty_to_move_the_camera_to_, Camera_selector_zoom_in, Is_there_a_wall___zoom_in_, Which_room_to_reverse_hover_animation_) {
  registerOnClick(Which_room_trigger_, false, false, [0,1,2], function() {
    current_camera = Camera_selector_zoom_in;
    if (zoomed_in == false) {
      changeVis(room_animation_triggers, false);
      set_room_animation_frame_timer();
      registerSetTimeout((room_animation_frame / 2 + 0.5) / 24, function() {

        operateAnimation('PLAY', getAnimations(Is_there_a_wall___zoom_in_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
                function() {}, false);


        operateAnimation('PLAY', getAnimations(Which_animation_to_play___all_the_rooms___current_one_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
                function() {}, false);

            tweenCamera(Empty_to_move_the_camera_to_, Which_room_does_the_camera_look_to_, 0.8, function() {
          zoomed_in = true;
          changeVis(getEntityByName(furniture_triggers, 'OBJECT'), true);
        }, 0);
        setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 10);
        setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 100);
      });
    }
  }, function() {});
}

// outline puzzle
function outline(objSelector, doWhat) {
    var objNames = retrieveObjectNames(objSelector);

    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}

// Describe this function...
function Outline_hovered_object(Outline_trigger_, Outline_object_) {
  registerOnHover(Outline_trigger_, false, function() {
    outline(Outline_object_, 'ENABLE');
  }, function() {
    outline(Outline_object_, 'DISABLE');
  });
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        bindListener(elem, eventType, callback);
    }
}

function listsGetSortCompare(type, direction) {
  var compareFuncs = {
    'NUMERIC': function(a, b) {
        return Number(a) - Number(b); },
    'TEXT': function(a, b) {
        return a.toString() > b.toString() ? 1 : -1; },
    'IGNORE_CASE': function(a, b) {
        return a.toString().toLowerCase() > b.toString().toLowerCase() ? 1 : -1; },
  };
  var compare = compareFuncs[type];
  return function(a, b) { return compare(a, b) * direction; };
}

// Describe this function...
function set_room_animation_frame_timer() {
  room_animation_frame = [getAnimationFrame('toilet_trigger'), getAnimationFrame('bedroom_trigger'), getAnimationFrame('bathroom_trigger'), getAnimationFrame('entrance_trigger'), getAnimationFrame('boiler_room_trigger'), getAnimationFrame('living_room_trigger'), getAnimationFrame('kitchen_trigger')].slice().sort(listsGetSortCompare("NUMERIC", -1))[0];
}

// Describe this function...
function Hoover_over_room_animation(Which_room_is_hoovered_, Which_room_to_trigger_hoover_animation_) {
  registerOnHover(Which_room_is_hoovered_, false, function() {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);

    operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
            function() {}, false);


    operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
            function() {}, false);

        }, function() {
    setHTMLElemStyle('cursor', 'default', ['BODY'], false);
    if (isAnimationPlaying(getAnimations(Which_room_to_trigger_hoover_animation_))) {

      operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
              function() {}, true);

          } else {

      operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
              function() {}, true);

          }
  });
}


animations_except_garden = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'living_room'], ['GROUP', 'toilet'], ['GROUP', 'entrance'], ['GROUP', 'study_room']];
animations_except_study_room = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'living_room'], ['GROUP', 'toilet'], ['GROUP', 'entrance'], ['GROUP', 'garden']];
animations_except_boiler_room = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_kitchen = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'living_room'], ['GROUP', 'study_room'], ['GROUP', 'garden'], ['GROUP', 'entrance'], ['GROUP', 'toilet']];
animations_except_bedroom = [['GROUP', 'bathroom'], ['GROUP', 'living_room'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_bathroom = [['GROUP', 'living_room'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_toilet = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_living_room = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_entrance = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'living_room'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];

registerOnClick('radiator_living_room_trigger', false, false, [0,1,2], function() {

  operateAnimation('SET_SPEED', getAnimations(['GROUP', 'radiator_living_room']), null, null, 'AUTO', 1,
          function() {}, false);


  operateAnimation('PLAY', getAnimations(['GROUP', 'radiator_living_room']), 150, 170, 'LoopOnce', 0.5,
          function() {}, false);

      }, function() {
  if (zoomed_in == true && getAnimationFrame('Cylinder.013') == 170) {
    if (isAnimationPlaying(getAnimations(['GROUP', 'radiator_living_room']))) {

      operateAnimation('SET_SPEED', getAnimations(['GROUP', 'radiator_living_room']), null, null, 'AUTO', 1,
              function() {}, true);

          } else {

      operateAnimation('PLAY', getAnimations(['GROUP', 'radiator_living_room']), 150, 170, 'LoopOnce', 1,
              function() {}, true);

          }
  }
});


operateAnimation('STOP', getAnimations(['ALL_OBJECTS']), null, null, 'AUTO', 1,
        function() {}, false);


furniture_triggers = [['GROUP', 'furniture_triggers_living_room'], null, null];

changeVis(getEntityByName(furniture_triggers, 'OBJECT'), false);

room_animation_triggers = ['toilet_trigger', 'bedroom_trigger', 'kitchen_trigger', 'bathroom_trigger', 'entrance_trigger', 'boiler_room_trigger', 'living_room_trigger', 'garden_trigger', 'study_room_trigger'];


animateParam(0, 10, 3, 'Linear', 'InOut', 0, false, 'GG/+ugsZNH.99/2]3EWs',
    function() {
  setMaterialColor('Base white  material dark shade anim', '<no colors>', 0.5, 0.5, 0.5, '');
},
    function() {});


registerOnClick('cupboard_trigger', false, false, [0,1,2], function() {

  operateAnimation('SET_SPEED', getAnimations(['GROUP', 'cuboard']), null, null, 'AUTO', 1,
          function() {}, false);


  operateAnimation('PLAY', getAnimations(['GROUP', 'cuboard']), 150, 170, 'LoopOnce', 1,
          function() {}, false);

      }, function() {
  if (zoomed_in == true && getAnimationFrame('cupboard_trigger') == 170) {
    if (isAnimationPlaying(getAnimations(['GROUP', 'cuboard']))) {

      operateAnimation('SET_SPEED', getAnimations(['GROUP', 'cuboard']), null, null, 'AUTO', 1,
              function() {}, true);

          } else {

      operateAnimation('PLAY', getAnimations(['GROUP', 'cuboard']), 150, 170, 'LoopOnce', 1,
              function() {}, true);

          }
  }
});

eventHTMLElem('click', 'popup-cross', true, function(event) {
  setHTMLElemStyle('transform', 'translate(300%, -50%)', 'text-container-phone', true);
});

room_animation_duration = 20;

rooms_disapearing_duration = 135;

zoomed_in = false;

camera_animation_duration = 60;

registerOnHover('background', false, function() {
  if (zoomed_in == true) {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);
  }
}, function() {
  setHTMLElemStyle('cursor', 'default', ['BODY'], false);
});

Update_the_text_in_the_Pop_up('radiator_living_room_trigger', ('          <h1 id="popup_room">Séjour</h1>' + '\n' +
'          <h1 id="popup_object">Radiateur.</h1>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Dépoussiérage et purge.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Entretien et contrôle périodique conformément aux dispositions du bail et à la réglementation en vigueur. Gaz : tous les 2 ans. Autres énergies : tous les ans.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Chauffage suffisant de l\'habitation.</p>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Tous remplacements.</p>'));
Update_the_text_in_the_Pop_up('electricity_living_room_trigger', ('          <h1 id="popup_room">Séjour</h1>' + '\n' +
'          <h1 id="popup_object">Plafonnier, prise de courant, interrupteur.</h1>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Remise en état des dégâts suite au placement des luminaires. </p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Le locataire est tenu de laisser aux points lumineux des fils en attente d\'une longueur de plus ou moins 10 cm. S\'il coupe les fils au raz du plafond ou du mur, il sera tenu au remplacement des fils dans la gaine.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Le locataire doit veiller à entretenir l\'installation électrique et ne pas surcharger celle-ci en tout ou en partie.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Remplacement des ampoules, tubes d\'éclairage, des interrupteurs, soquets et des prises de courant cassés, même suite un usage normal.</p>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Tous remplacements des câblages pour tous services sauf si causés par des modifications du locataire. </p>'));
Update_the_text_in_the_Pop_up('window_living_room_trigger', ('          <h1 id="popup_room">Séjour</h1>' + '\n' +
'          <h1 id="popup_object">Fenètres</h1>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Remplacement des vitres brisées par sa faute.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Nettoyage régulier des vitres accessibles.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Remplacement des vitres brisées par sa faute.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Réfection des griffes faites aux vitres et aux châssis.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Maintenir libre écoulement des eaux de condensation des châssis, sous peine de voir sa responsabilité engagée pour les dégâts en résultant (humidité, mérules…).</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Réfection des griffes faites aux vitres et aux châssis. En l\'absence de VMC  : aération quotidienne des locaux.</p>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Réparations nécessaires, autres que locatives, et remplacement.</p>'));
Update_the_text_in_the_Pop_up('fireplace_living_room_trigger', ('          <h1 id="popup_room">Séjour</h1>' + '\n' +
'          <h1 id="popup_object">Feu ouvert</h1>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Ramonage annuel, par un professionnel, des conduits d\'évacuation et à tout le moins avant sa sortie des lieux loués.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Entretien et réparation notamment de l’âtre, du contre-cœur, des chambranles et de la tablette de l’âtre.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Nettoyage, cirage éventuel. Le locataire n\'est toutefois pas responsable du brunissement naturel causé par la chaleur ou la fumée résultant d\'un usage normal.</p>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Réparations nécessaires, autres que locatives, et remplacement.</p>'));
Update_the_text_in_the_Pop_up('ventilation_opening_living_room_trigger', ('          <h1 id="popup_room">Séjour</h1>' + '\n' +
'          <h1 id="popup_object">Bouche de ventilation</h1>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Nettoyage des bouches qui doivent rester ouvertes en permanence.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Nettoyage et/ou remplacement régulier des filtres.</p>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Réparations nécessaires, autres que locatives, et remplacement.</p>'));

Play_zoom_out_animation('living', animations_except_living_room, null);
Play_zoom_out_animation('entrance', animations_except_entrance, 'trigger_entrance_wall_animation');
Play_zoom_out_animation('kitchen', animations_except_kitchen, 'trigger_kitchen_wall_animation');
Play_zoom_out_animation('bathroom', animations_except_bathroom, null);
Play_zoom_out_animation('boiler', animations_except_boiler_room, null);
Play_zoom_out_animation('bedroom', animations_except_bedroom, null);
Play_zoom_out_animation('toilet', animations_except_toilet, null);
Play_zoom_out_animation('garden', animations_except_garden, null);
Play_zoom_out_animation('study_room', animations_except_study_room, 'trigger_study_room_animation');

Outline_hovered_object('electricity_living_room_trigger', ['GROUP', 'switch_living_room']);
Outline_hovered_object('window_living_room_trigger', ['GROUP', 'window_living_room']);
Outline_hovered_object('radiator_living_room_trigger', ['GROUP', 'radiator_living_room']);
Outline_hovered_object('fireplace_living_room_trigger', ['GROUP', 'fireplace_living_room']);
Outline_hovered_object('ventilation_opening_living_room_trigger', ['GROUP', 'ventilation_opening_living_room']);

registerOnClick('lamp_trigger', false, false, [0,1,2], function() {}, function() {});

outline('Cylinder', 'ENABLE');

Zoom_to_clicked_room('living_room_trigger', animations_except_living_room, 'camera_target_living_room', 'camera_position_living_room', 'living', null, ['GROUP', 'living_room']);
Zoom_to_clicked_room('entrance_trigger', animations_except_entrance, 'camera_target_entrance', 'camera_position_entrance', 'entrance', 'trigger_entrance_wall_animation', ['GROUP', 'entrance']);
Zoom_to_clicked_room('kitchen_trigger', animations_except_kitchen, 'camera_target_kitchen', 'camera_position_kitchen', 'kitchen', 'trigger_kitchen_wall_animation', ['GROUP', 'kitchen']);
Zoom_to_clicked_room('bathroom_trigger', animations_except_bathroom, 'camera_target_bathroom', 'camera_position_bathroom', 'bathroom', null, ['GROUP', 'bathroom']);
Zoom_to_clicked_room('boiler_room_trigger', animations_except_boiler_room, 'camera_target_boiler_room', 'camera_position_boiler_room', 'boiler', null, ['GROUP', 'boiler_room']);
Zoom_to_clicked_room('bedroom_trigger', animations_except_bedroom, 'camera_target_bedroom', 'camera_position_bedroom', 'bedroom', null, ['GROUP', 'bedroom']);
Zoom_to_clicked_room('toilet_trigger', animations_except_toilet, 'camera_target_toilet', 'camera_position_toilet', 'toilet', null, ['GROUP', 'toilet']);
Zoom_to_clicked_room('garden_trigger', animations_except_garden, 'camera_target_garden', 'camera_position_garden', 'garden', null, ['GROUP', 'garden']);
Zoom_to_clicked_room('study_room_trigger', animations_except_study_room, 'camera_target_study_room', 'camera_position_study_room', 'study_room', 'trigger_study_room_animation', ['GROUP', 'study_room']);

Hoover_over_room_animation('entrance_trigger', ['GROUP', 'entrance']);
Hoover_over_room_animation('kitchen_trigger', ['GROUP', 'kitchen']);
Hoover_over_room_animation('living_room_trigger', ['GROUP', 'living_room']);
Hoover_over_room_animation('bathroom_trigger', ['GROUP', 'bathroom']);
Hoover_over_room_animation('toilet_trigger', ['GROUP', 'toilet']);
Hoover_over_room_animation('boiler_room_trigger', ['GROUP', 'boiler_room']);
Hoover_over_room_animation('bedroom_trigger', ['GROUP', 'bedroom']);
Hoover_over_room_animation('garden_trigger', ['GROUP', 'garden']);
Hoover_over_room_animation('study_room_trigger', ['GROUP', 'study_room']);

if (zoomed_in == true) {
  Update_the_text_in_the_Pop_up('background', ('          <div class="popup-cross" id="popup-cross"></div>' + '\n' +
  '          <h1 id="popup_room">Maquette PLE</h1>' + '\n' +
  '          <h1 id="popup_object">Interactive et explorable</h1>' + '\n' +
  '          <div id="dividing_line"></div>' + '\n' +
  '          <p id="popup_locataire">Navigation</p>' + '\n' +
  '          <p id="popup_paragraph"><span id="color_overwrite">•</span> Utiliser la souris pour tourner autour de la maquette.</p>' + '\n' +
  '          <p id="popup_paragraph"><span id="color_overwrite">•</span> Clickez sur une pièce pour zoomer.</p>' + '\n' +
  '          <p id="popup_paragraph"><span id="color_overwrite">•</span> Sélectionner un objet</p>' + '\n' +
  '          <div id="dividing_line"></div>' + '\n' +
  '          <p id="popup_locataire">Information</p>' + '\n' +
  '          <p id="popup_paragraph"><span id="color_overwrite">•</span> Une fois l\'objet cliqué, des informations s\'affichent.</p>'));
}



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };

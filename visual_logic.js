/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.6.0
 * Sun, 02 Jun 2024 19:37:17 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    /**
     * Get an HTML element by the given id.
     * @param {(string|Array<string>)} id An HTML element id or an array in the
     * format ["CONTAINER"] (app's container HTML element), or in the format
     * ["WINDOW"] (page's window object), or in the format ["DOCUMENT"] (page's
     * document object), or in the format ["BODY"] (document's body element) or in
     * the format ["QUERYSELECTOR"] (CSS selector string).
     * @param {boolean} [isParent=false] Use the parent document/window to search
     * for the element.
     * @returns {?(HTMLElement|Window|Document)} An HTML element, window,
     * document depending on the given "id" parameter or "null" if nothing was
     * found.
     */
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
    
    /**
     * Get an array of HTML elements or a single HTML element by the given ids/id.
     * @param {Array<string>} ids An array of HTML element ids or an array with its
     * first element being "CONTAINER" (app's container HTML element),
     * "WINDOW" (page's window object), "DOCUMENT" (page's document object),
     * "BODY" (document's body element) or "QUERYSELECTOR" (CSS selector string).
     * @param {boolean} [isParent=false] Use the parent document/window to search
     * for elements.
     * @returns {?(Array<?HTMLElement>|HTMLElement|Window|Document)} An array of
     * HTML elements or a single HTML element, window, document depending on the
     * given "ids" parameter or "null" if nothing was found.
     */
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    /**
     * Check if the given object is "worth processing", i.e. not irrelevant nor
     * purely utilitarian. This function is useful for listing all relevant objects
     * from a scene (see "objectList" and "groupList" puzzles) and for filtering out
     * irrelevant ones when traversing a scene.
     * @param {v3d.Object3D} obj Object to check.
     * @returns {boolean} Check result.
     */
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
    
    /**
     * Get the names of all objects belonging to the given group.
     * @param {string} groupName Group name.
     * @returns {Array<string>} Array of names of all objects belonging to the given
     * group.
     */
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    /**
     * Get the names of all objects on the scene.
     * @returns {Array<string>} Array of names of all scene objects.
     */
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    /**
     * Accumulate object names from the given "currObjNames" parameter.
     * This is just a helper function which is supposed to be called from
     * "retrieveObjectNames".
     * @param {(string|Array)} objNames An object name, an array of object
     * names, an array in the format ["GROUP", GROUP_NAME], an array in the format
     * ["ALL_OBJECTS"].
     * @param {Array<string>} namesAccum Array accumulating object names.
     */
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    /**
     * Retreive object names from the given "objNames" parameter which potentially
     * represents an object, or an array of objects, or a group or all objects at
     * once. Empty string names ('') are always filtered out.
     * @param {(string|Array)} objNames An object name, an array of object
     * names, an array in the format ["GROUP", GROUP_NAME], an array in the format
     * ["ALL_OBJECTS"].
     * @returns {Array<string>} Array of retrieved object names.
     */
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    /**
     * Check whether 2 event listeners are the same or not.
     * NOTE: "capture" is the only option that affects the fact if the listeners are
     * the same or not.
     * @see https://dom.spec.whatwg.org/#ref-for-dom-eventtarget-addeventlistener%E2%91%A2
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener#matching_event_listeners_for_removal
     * @param {EventTarget} target0 Event target the first event listener is
     * registered on.
     * @param {string} type0 Event type of the first even listener.
     * @param {?Function} listener0 Listener object (null, function or an object
     * with a handleEvent() method) of the first event listener.
     * @param {(Object|boolean)} optionsOrUseCapture0 Event listener options (or the
     * useCapture flag) of the first event listener.
     * @param {EventTarget} target1 Event target the second listener is registered
     * on.
     * @param {string} type1 Event type of the second even listener.
     * @param {?Function} listener1 Listener object (null, function or an object
     * with a handleEvent() method) of the second event listener.
     * @param {(Object|boolean)} optionsOrUseCapture1 Event listener options (or the
     * useCapture flag) of the second event listener.
     * @returns {boolean} Check result.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     */
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
    
    /**
     * Add the specified event listener to the specified event target. Also register
     * it in _pGlob.eventListeners for easier removal further. This function doesn't
     * add the exact same listener if it was already added.
     *
     * NOTE: automatic removal of an event listener via options.once and
     * options.signal is not reflected in _pGlob.eventListeners. In such cases
     * one must call unbindListener() manually to keep _pGlob.eventListeners
     * updated and to avoid potential issues with how the code checks if the given
     * listener already exists in _pGlob.eventListeners or not.
     *
     * @param {EventTarget} target Event target.
     * @param {string} type Event type.
     * @param {?Function} listener Listener object (null, function or an object
     * with a handleEvent() method).
     * @param {(Object|boolean)} optionsOrUseCapture Event listener options (or the
     * useCapture flag).
     * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
     */
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    /**
     * Get the given scene's animation framerate.
     * @param {v3d.Scene} scene Scene.
     * @returns {number} Scene's animation framerate.
     */
    function getSceneAnimFrameRate(scene) {
        if (scene && 'animFrameRate' in scene.userData) {
            return scene.userData.animFrameRate;
        }
        return 24;
    }
    
    /**
     * Get a scene that contains the root of the given action.
     * @param {v3d.AnimationAction} action Animation action.
     * @returns {?v3d.Scene} The scene containing the given action or "null" if no
     * such scene found.
     */
    function getSceneByAction(action) {
        const root = action.getRoot();
        let scene = root.type === 'Scene' ? root : null;
        root.traverseAncestors(ancObj => {
            if (ancObj.type === 'Scene') {
                scene = ancObj;
            }
        });
        return scene;
    }
    
    /**
     * Get object by its name from the scene.
     * @param {string} objName Object name.
     * @returns {?v3d.Object3D} Object or null if not found.
     */
    function getObjectByName(objName) {
        let objFound = null;
    
        const runTime = _pGlob !== undefined;
        if (runTime && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (runTime) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    /**
     * Get the name of the given object. This function also considers auto-generated
     * child meshes of multi-material objects.
     * @param {v3d.Object3D} obj The object.
     * @returns {string} The name of the object.
     */
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
    
    /**
     * A function to use as a callback for the initObjectPicking function. It's
     * supposed to handle the results of object picking.
     * @callback pickObjectCallback
     * @param {Array<Object>} intersects The array containing the results of object
     * picking in the form of intersection data from raycasting. Has the same format
     * as the result of the v3d.Raycaster's intersectObjects() method.
     * @param {(MouseEvent|TouchEvent)} event The event that was used for object
     * picking.
     */
    
    /**
     * Bind object picking functionality to the given mouse event, e.g. "mousemove",
     * "mousedown", "dblclick". An additional listener for a touch event
     * ("touchstart" or "touchend") is also registered.
     * @param {pickObjectCallback} callback A callback function receiving the
     * results of object picking.
     * @param {string} eventType The type of a MouseEvent, e.g. "mousemove",
     * "mousedown", "dblclick".
     * @param {boolean} [mouseDownUseTouchStart=false] Use the "touchstart" (if true)
     * or the "touchend" (if false) touch event for object picking for touch devices.
     * @param {Array<number>} [allowedMouseButtons=null] The array representing
     * mouse buttons allowed to trigger object picking. 0 - left mouse button,
     * 1 - middle mouse button, 2 - right mouse button. "null" (by default) means
     * that object picking will be triggered regardless of any mouse buttons pressed
     * (useful for events that don't require button pressing, e.g. "mousemove").
     * [0, 1, 2] means that a mouse event caused by pressing any of those buttons
     * will trigger object picking (useful for filtering out unwanted actions, e.g.
     * usually clicking with the middle/right mouse buttons).
     */
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        const elem = appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    /**
     * Check if a particular object is among the given array of objects. This
     * function also considers auto-generated child meshes of multi-material
     * objects.
     * @param {string} objNameToCheck The name of the object to check if it's among
     * the given array of objects.
     * @param {Array} objNames Array of the object names to search in.
     * @returns {boolean} Check result.
     */
    function isObjectAmongObjects(objNameToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            if (objNameToCheck === objNames[i]) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objNames[i]);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        if (objNameToCheck === obj.children[j].name) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    /**
     * Transform the given coordinates from one space to another. Can be used with
     * both v3d.Vector3 or v3d.Euler.
     * @param {(v3d.Vector3|v3d.Euler)} coords Coordinates to transform.
     * @param {string} spaceFrom Space to transform from.
     * @param {string} spaceTo Space to transform into.
     * @param {boolean} [noSignChange=false] Don't change a component's sign in case
     * of the Z->(-Y), Y->(-Z) transformations. "true" is relevant for vectors
     * containing values that shouldn't change the sign (e.g. scale, dimension,
     * etc...).
     * @returns {(v3d.Vector3|v3d.Euler)} Transformed coordinates.
     */
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
    
    /**
     * Get the coordinate system of the current scene.
     * @returns {string} Scene's coordinate system.
     */
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }

    return {
        getElements, retrieveObjectNames, bindListener, getSceneAnimFrameRate,
        getSceneByAction, getObjectByName, getObjectName, initObjectPicking,
        isObjectAmongObjects, transformCoordsSpace, getSceneCoordSystem,
    };
};

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'block', 'start-button', true);
  setHTMLElemStyle('display', 'none', 'loading-icon', true);
})();
};


// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = false;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["Hide all the pop-up elements"] = Hide_all_the_pop_up_elements;
this.procedures["Update the text in the Pop up"] = Update_the_text_in_the_Pop_up;
this.procedures["Zoom to clicked room"] = Zoom_to_clicked_room;
this.procedures["set_room_animation_frame_timer"] = set_room_animation_frame_timer;
this.procedures["Play zoom out animation"] = Play_zoom_out_animation;
this.procedures["Hoover over room animation"] = Hoover_over_room_animation;
this.procedures["Turn object red when hovered"] = Turn_object_red_when_hovered;

var animations_except_attic_room, furniture_triggers, room_animation_triggers, zoomed_in, room_animation_duration, rooms_disapearing_duration, camera_animation_duration, object_clicked, paragraph_text, Which_megamenu_trigger___object_, Which_arrow_to_go_back_, Which_room_trigger_, Which_megamenu_trigger_, Which_animation_to_play___all_the_rooms___current_one_, Which_room_does_the_camera_look_to_, Empty_to_move_the_camera_to_, Camera_selector_zoom_in, Is_there_a_wall___zoom_in_, Which_room_to_reverse_hover_animation_, Pop_Up_for_specific_room, Which_room_to_trigger_hoover_animation_, allow_background_click, What_is_the_current_camera_, Which_animation_to_play___all_rooms___the_current_one_, Is_there_a_wall___zoom_out_, Which_room_is_hoovered_, Which_html_element_is_hovered_, room_object_is_selected, Trigger_object_to_turn_red, Group_object_to_turn_red, animations_except_bathroom, room_animation_frame, animations_except_toilet, current_camera, animations_except_bedroom, animations_except_entrance, animations_except_living_room, animations_except_kitchen, animations_except_boiler_room, animations_except_laundry_room, animations_except_garden;

// getAnimations puzzle
function getAnimations(objSelector) {
    const objNames = PzLib.retrieveObjectNames(objSelector);

    const animations = [];
    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i];
        if (!objName)
            continue;
        // use objName as animName - for now we have one-to-one match
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, objName);
        if (action)
            animations.push(objName);
    }
    return animations;
}

_pGlob.animMixerCallbacks = [];

var initAnimationMixer = function() {

    function onMixerFinished(e) {
        var cb = _pGlob.animMixerCallbacks;
        var found = [];
        for (var i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (var i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            PzLib.bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;
        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();
                if (loop && (loop != "AUTO"))
                    action.loop = v3d[loop];
                var scene = PzLib.getSceneByAction(action);
                var frameRate = PzLib.getSceneAnimFrameRate(scene);

                action.repetitions = Infinity;

                var timeScale = Math.abs(parseFloat(speed));
                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                var callbacks = _pGlob.animMixerCallbacks;
                var found = false;

                for (var j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            var callbacks = _pGlob.animMixerCallbacks;
            for (var j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            var scene = PzLib.getSceneByAction(action);
            var frameRate = PzLib.getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            var timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// getEntityByName puzzle
function getEntityByName(name, getWhat) {
    switch (getWhat) {
        case 'OBJECT':
        case 'ANIMATION':
        case 'MATERIAL':
            return name;
        case 'GROUP':
            return ['GROUP', name];
    }
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

function setScreenScale(factor) {

    // already have maximum pixel ratio in HiDPI mode
    if (!appInstance.useHiDPIRenderPass)
        appInstance.renderer.setPixelRatio(factor);

    if (appInstance.postprocessing)
        appInstance.postprocessing.composer.setPixelRatio(factor);

    // to update possible post-processing passes
    appInstance.onResize();
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// Describe this function...
function Hide_all_the_pop_up_elements() {
  setHTMLElemStyle('display', 'none', 'updated-object-text', true);
  setHTMLElemStyle('display', 'none', 'zoomed-out-text', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_room_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_attic_room_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_bathroom_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_toilet_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_bedroom_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_entrance_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_living_room_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_kitchen_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_boiler_room_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_laundry_room_popup', true);
  setHTMLElemStyle('display', 'none', 'back_arrow_garden_popup', true);
  setHTMLElemStyle('display', 'none', 'attic-room-text', true);
  setHTMLElemStyle('display', 'none', 'bathroom-text', true);
  setHTMLElemStyle('display', 'none', 'toilet-text', true);
  setHTMLElemStyle('display', 'none', 'bedroom-text', true);
  setHTMLElemStyle('display', 'none', 'entrance-text', true);
  setHTMLElemStyle('display', 'none', 'living-room-text', true);
  setHTMLElemStyle('display', 'none', 'kitchen-text', true);
  setHTMLElemStyle('display', 'none', 'boiler-room-text', true);
  setHTMLElemStyle('display', 'none', 'laundry-room-text', true);
  setHTMLElemStyle('display', 'none', 'garden-text', true);
}

// whenHovered puzzle
PzLib.initObjectPicking(function(intersects, event) {

    var prevHovered = _pGlob.hoveredObject;
    var currHovered = '';

    // the event might happen before hover registration
    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    // search for closest hovered object

    var lastIntersectIndex = Infinity;
    _pGlob.objHoverInfo.forEach(function(el) {
        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);

            if (PzLib.isObjectAmongObjects(objName, PzLib.retrieveObjectNames(el.objSelector)) && i <= lastIntersectIndex) {
                currHovered = objName;
                lastIntersectIndex = i;
            }
        }
    });

    if (prevHovered == currHovered) return;

    // first - all "out" callbacks, then - all "over"
    _pGlob.objHoverInfo.forEach(function(el) {
        if (PzLib.isObjectAmongObjects(prevHovered, PzLib.retrieveObjectNames(el.objSelector))) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1](event);
        }
    });

    _pGlob.objHoverInfo.forEach(function(el) {
        if (PzLib.isObjectAmongObjects(currHovered, PzLib.retrieveObjectNames(el.objSelector))) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0](event);
        }
    });

    _pGlob.hoveredObject = currHovered;
}, 'mousemove');

// whenHovered puzzle
function registerOnHover(objSelector, xRay, cbOver, cbOut) {

    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    _pGlob.objHoverInfo.push({
        objSelector: objSelector,
        callbacks: [cbOver, cbOut],
        xRay: xRay
    });
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    PzLib.initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);
            var objNames = PzLib.retrieveObjectNames(objSelector);

            if (PzLib.isObjectAmongObjects(objName, objNames)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}

// Describe this function...
function Update_the_text_in_the_Pop_up(object_clicked, paragraph_text, Which_megamenu_trigger___object_, Which_arrow_to_go_back_) {
  registerOnHover(object_clicked, false, function() {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);
  }, function() {
    setHTMLElemStyle('cursor', 'default', ['BODY'], false);
  });
  registerOnClick(object_clicked, false, false, [0,1,2], function() {
    setHTMLElemAttribute('innerHTML', paragraph_text, 'text-block-phone', true);
    setHTMLElemStyle('opacity', '0', 'text-block', true);
    registerSetTimeout(0.4, function() {
      setHTMLElemAttribute('innerHTML', paragraph_text, 'updated-object-text', true);
      setHTMLElemStyle('opacity', '1', 'text-block', true);
      Hide_all_the_pop_up_elements();
      setHTMLElemStyle('display', 'block', Which_arrow_to_go_back_, true);
      setHTMLElemStyle('display', 'block', 'updated-object-text', true);
    });
  }, function() {});
  eventHTMLElem('click', Which_megamenu_trigger___object_, true, function(event) {
    setHTMLElemAttribute('innerHTML', paragraph_text, 'text-block-phone', true);
    setHTMLElemStyle('opacity', '0', 'text-block', true);
    registerSetTimeout(0.4, function() {
      setHTMLElemAttribute('innerHTML', paragraph_text, 'updated-object-text', true);
      setHTMLElemStyle('opacity', '1', 'text-block', true);
      Hide_all_the_pop_up_elements();
      setHTMLElemStyle('display', 'block', Which_arrow_to_go_back_, true);
      setHTMLElemStyle('display', 'block', 'updated-object-text', true);
    });
  });
}

// isAnimationPlaying puzzle
function isAnimationPlaying(animations) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];
    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (!animName)
            continue;
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (action && action.isRunning())
            return true;
    }
    return false;
}

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = PzLib.transformCoordsSpace(worldPos,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = PzLib.getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = PzLib.transformCoordsSpace(worldTarget,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = PzLib.getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = PzLib.retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = PzLib.getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('setCameraParam: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controls) {
                console.error('setCameraParam: The "' + camName +'" camera has no controller');
                return;
            } else if ((isSetOrbitParam && cam.controls.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controls.type != 'FIRST_PERSON')) {
                console.error('setCameraParam: Incompatible camera controller: ' + cam.controls.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controls.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controls.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controls.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controls.enableZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controls.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controls.orbitMinDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controls.orbitMaxDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controls.orbitMinZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controls.orbitMaxZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controls.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controls.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controls.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controls.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controls.orbitEnableTurnover = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controls.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

// Describe this function...
function Zoom_to_clicked_room(Which_room_trigger_, Which_megamenu_trigger_, Which_animation_to_play___all_the_rooms___current_one_, Which_room_does_the_camera_look_to_, Empty_to_move_the_camera_to_, Camera_selector_zoom_in, Is_there_a_wall___zoom_in_, Which_room_to_reverse_hover_animation_, Pop_Up_for_specific_room, Which_room_to_trigger_hoover_animation_) {
  registerOnClick(Which_room_trigger_, false, false, [0,1,2], function() {
    current_camera = Camera_selector_zoom_in;
    if (zoomed_in == false) {
      setHTMLElemStyle('cursor', 'default', ['BODY'], false);
      if (isAnimationPlaying(getAnimations(Which_room_to_trigger_hoover_animation_))) {

        operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
                function() {}, true);

            } else {

        operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
                function() {}, true);

            }
      zoomed_in = true;
      changeVis(room_animation_triggers, false);
      set_room_animation_frame_timer();
      registerSetTimeout((room_animation_frame / 2 + 0.5) / 24, function() {

        operateAnimation('PLAY', getAnimations(Is_there_a_wall___zoom_in_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
                function() {}, false);


        operateAnimation('PLAY', getAnimations(Which_animation_to_play___all_the_rooms___current_one_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
                function() {}, false);

            tweenCamera(Empty_to_move_the_camera_to_, Which_room_does_the_camera_look_to_, 0.8, function() {
          allow_background_click = true;
          changeVis(getEntityByName(furniture_triggers, 'OBJECT'), true);
        }, 0);
        setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 30);
        setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 90);
        setHTMLElemStyle('opacity', '0', 'text-block', true);
        registerSetTimeout(0.4, function() {
          Hide_all_the_pop_up_elements();
          setHTMLElemStyle('display', 'block', Pop_Up_for_specific_room, true);
          setHTMLElemStyle('display', 'block', 'back_arrow_room_popup', true);
          setHTMLElemStyle('opacity', '1', 'text-block', true);
        });
      });
    }
  }, function() {});
  eventHTMLElem('click', Which_megamenu_trigger_, true, function(event) {
    current_camera = Camera_selector_zoom_in;
    if (zoomed_in == false) {
      setHTMLElemStyle('cursor', 'default', ['BODY'], false);
      if (isAnimationPlaying(getAnimations(Which_room_to_trigger_hoover_animation_))) {

        operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
                function() {}, true);

            } else {

        operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
                function() {}, true);

            }
      zoomed_in = true;
      changeVis(room_animation_triggers, false);
      set_room_animation_frame_timer();
      registerSetTimeout((room_animation_frame / 2 + 0.5) / 24, function() {

        operateAnimation('PLAY', getAnimations(Is_there_a_wall___zoom_in_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
                function() {}, false);


        operateAnimation('PLAY', getAnimations(Which_animation_to_play___all_the_rooms___current_one_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
                function() {}, false);

            tweenCamera(Empty_to_move_the_camera_to_, Which_room_does_the_camera_look_to_, 0.8, function() {
          allow_background_click = true;
          changeVis(getEntityByName(furniture_triggers, 'OBJECT'), true);
        }, 0);
        setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 30);
        setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 90);
        setHTMLElemStyle('opacity', '0', 'text-block', true);
        registerSetTimeout(0.4, function() {
          Hide_all_the_pop_up_elements();
          setHTMLElemStyle('display', 'block', Pop_Up_for_specific_room, true);
          setHTMLElemStyle('display', 'block', 'back_arrow_room_popup', true);
          setHTMLElemStyle('opacity', '1', 'text-block', true);
        });
      });
    }
  });
}

// getAnimationFrame puzzle
function getAnimationFrame(animName) {
    if (!animName)
        return;
    var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
    if (action) {
        var scene = PzLib.getSceneByAction(action);
        var frameRate = PzLib.getSceneAnimFrameRate(scene);
        return action.time * frameRate;
    } else {
        return;
    }
}

function listsGetSortCompare(type, direction) {
  var compareFuncs = {
    'NUMERIC': function(a, b) {
        return Number(a) - Number(b); },
    'TEXT': function(a, b) {
        return a.toString() > b.toString() ? 1 : -1; },
    'IGNORE_CASE': function(a, b) {
        return a.toString().toLowerCase() > b.toString().toLowerCase() ? 1 : -1; },
  };
  var compare = compareFuncs[type];
  return function(a, b) { return compare(a, b) * direction; };
}

// Describe this function...
function set_room_animation_frame_timer() {
  room_animation_frame = [getAnimationFrame('attic_room_trigger'), getAnimationFrame('bathroom_trigger'), getAnimationFrame('toilet_trigger'), getAnimationFrame('bedroom_trigger'), getAnimationFrame('entrance_trigger'), getAnimationFrame('living_room_trigger'), getAnimationFrame('kitchen_trigger'), getAnimationFrame('boiler_room_trigger'), getAnimationFrame('laundry_room_trigger'), getAnimationFrame('garden_trigger')].slice().sort(listsGetSortCompare("NUMERIC", -1))[0];
}

// Describe this function...
function Play_zoom_out_animation(What_is_the_current_camera_, Which_animation_to_play___all_rooms___the_current_one_, Is_there_a_wall___zoom_out_) {
  registerOnClick('background_sphere', false, false, [0,1,2], function() {
    if (allow_background_click == true && current_camera == What_is_the_current_camera_) {
      setHTMLElemStyle('cursor', 'default', ['BODY'], false);
      changeVis(getEntityByName(furniture_triggers, 'OBJECT'), false);
      setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 160);
      tweenCamera('camera_position_original', 'camera_target_origin', 0.8, function() {
        zoomed_in = false;
        allow_background_click = false;
        changeVis(room_animation_triggers, true);
        setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 160);
      }, 0);

      operateAnimation('PLAY', getAnimations(Which_animation_to_play___all_rooms___the_current_one_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
              function() {}, true);


      operateAnimation('PLAY', getAnimations(Is_there_a_wall___zoom_out_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
              function() {}, true);

          setHTMLElemStyle('opacity', '0', 'text-block', true);
      registerSetTimeout(0.4, function() {
        Hide_all_the_pop_up_elements();
        setHTMLElemStyle('display', 'block', 'zoomed-out-text', true);
        setHTMLElemStyle('opacity', '1', 'text-block', true);
      });
    }
  }, function() {});
  eventHTMLElem('click', 'back_arrow_room_popup', true, function(event) {
    if (allow_background_click == true && current_camera == What_is_the_current_camera_) {
      changeVis(getEntityByName(furniture_triggers, 'OBJECT'), false);
      setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 160);
      tweenCamera('camera_position_original', 'camera_target_origin', 0.8, function() {
        allow_background_click = false;
        zoomed_in = false;
        changeVis(room_animation_triggers, true);
        setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 160);
      }, 0);

      operateAnimation('PLAY', getAnimations(Which_animation_to_play___all_rooms___the_current_one_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
              function() {}, true);


      operateAnimation('PLAY', getAnimations(Is_there_a_wall___zoom_out_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
              function() {}, true);

          setHTMLElemStyle('opacity', '0', 'text-block', true);
      registerSetTimeout(0.4, function() {
        Hide_all_the_pop_up_elements();
        setHTMLElemStyle('display', 'block', 'zoomed-out-text', true);
        setHTMLElemStyle('opacity', '1', 'text-block', true);
      });
    }
  });
}

// Describe this function...
function Hoover_over_room_animation(Which_room_is_hoovered_, Which_room_to_trigger_hoover_animation_, Which_html_element_is_hovered_) {
  registerOnHover(Which_room_is_hoovered_, false, function() {
    if (zoomed_in == false) {
      setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);

      operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
              function() {}, false);


      operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
              function() {}, false);

          } else {
    }
  }, function() {
    if (zoomed_in == false) {
      setHTMLElemStyle('cursor', 'default', ['BODY'], false);
      if (isAnimationPlaying(getAnimations(Which_room_to_trigger_hoover_animation_))) {

        operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
                function() {}, true);

            } else {

        operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
                function() {}, true);

            }
    } else {
    }
  });
  eventHTMLElem('mouseover', Which_html_element_is_hovered_, true, function(event) {
    if (zoomed_in == false) {
      setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);

      operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
              function() {}, false);


      operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
              function() {}, false);

          } else {
    }
  });
  eventHTMLElem('mouseout', Which_html_element_is_hovered_, true, function(event) {
    if (zoomed_in == false) {
      setHTMLElemStyle('cursor', 'default', ['BODY'], false);
      if (isAnimationPlaying(getAnimations(Which_room_to_trigger_hoover_animation_))) {

        operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
                function() {}, true);

            } else {

        operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
                function() {}, true);

            }
    } else {
    }
  });
}

// assignMaterial puzzle
function assignMat(objSelector, matName) {
    var objNames = PzLib.retrieveObjectNames(objSelector);
    if (!matName)
        return;
    var mat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
    if (!mat)
        return;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (obj) {
            var firstSubmesh = obj.resolveMultiMaterial()[0];
            firstSubmesh.material = mat;
        }
    }
}

// Describe this function...
function Turn_object_red_when_hovered(Trigger_object_to_turn_red, Group_object_to_turn_red) {
  registerOnHover(Trigger_object_to_turn_red, false, function() {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);
    assignMat(Group_object_to_turn_red, 'toon_shader_red_bright');
  }, function() {
    if (room_object_is_selected == false) {
      assignMat(Group_object_to_turn_red, 'toon_shader_white');
      setHTMLElemStyle('cursor', 'default', ['BODY'], false);
    } else {
    }
  });
  registerOnClick(Trigger_object_to_turn_red, false, false, [0,1,2], function() {
    assignMat(Group_object_to_turn_red, 'toon_shader_red_bright');
    room_object_is_selected = true;
    setHTMLElemStyle('cursor', 'default', ['BODY'], false);
  }, function() {
    assignMat(Group_object_to_turn_red, 'toon_shader_white');
    room_object_is_selected = false;
  });
}


animations_except_attic_room = [null, ['GROUP', 'bathroom'], ['GROUP', 'toilet'], ['GROUP', 'bedroom'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'boiler_room'], ['GROUP', 'laundry_room'], ['GROUP', 'garden']];
animations_except_bathroom = [['GROUP', 'attic_room'], null, ['GROUP', 'toilet'], ['GROUP', 'bedroom'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'boiler_room'], ['GROUP', 'laundry_room'], ['GROUP', 'garden']];
animations_except_toilet = [['GROUP', 'attic_room'], ['GROUP', 'bathroom'], null, ['GROUP', 'bedroom'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'boiler_room'], ['GROUP', 'laundry_room'], ['GROUP', 'garden']];
animations_except_bedroom = [['GROUP', 'attic_room'], ['GROUP', 'bathroom'], ['GROUP', 'toilet'], null, ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'boiler_room'], ['GROUP', 'laundry_room'], ['GROUP', 'garden']];
animations_except_entrance = [['GROUP', 'attic_room'], ['GROUP', 'bathroom'], ['GROUP', 'toilet'], ['GROUP', 'bedroom'], null, ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'boiler_room'], ['GROUP', 'laundry_room'], ['GROUP', 'garden']];
animations_except_living_room = [['GROUP', 'attic_room'], ['GROUP', 'bathroom'], ['GROUP', 'toilet'], ['GROUP', 'bedroom'], ['GROUP', 'entrance'], null, ['GROUP', 'kitchen'], ['GROUP', 'boiler_room'], ['GROUP', 'laundry_room'], ['GROUP', 'garden']];
animations_except_kitchen = [['GROUP', 'attic_room'], ['GROUP', 'bathroom'], ['GROUP', 'toilet'], ['GROUP', 'bedroom'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], null, ['GROUP', 'boiler_room'], ['GROUP', 'laundry_room'], ['GROUP', 'garden']];
animations_except_boiler_room = [['GROUP', 'attic_room'], ['GROUP', 'bathroom'], ['GROUP', 'toilet'], ['GROUP', 'bedroom'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], null, ['GROUP', 'laundry_room'], ['GROUP', 'garden']];
animations_except_laundry_room = [['GROUP', 'attic_room'], ['GROUP', 'bathroom'], ['GROUP', 'toilet'], ['GROUP', 'bedroom'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'boiler_room'], null, ['GROUP', 'garden']];
animations_except_garden = [['GROUP', 'attic_room'], ['GROUP', 'bathroom'], ['GROUP', 'toilet'], ['GROUP', 'bedroom'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'boiler_room'], ['GROUP', 'laundry_room'], null];

furniture_triggers = [['GROUP', 'furniture_triggers_attic_room'], ['GROUP', 'furniture_triggers_bathroom'], ['GROUP', 'furniture_triggers_toilet'], ['GROUP', 'furniture_triggers_bedroom'], ['GROUP', 'furniture_triggers_entrance'], ['GROUP', 'furniture_triggers_living_room'], ['GROUP', 'furniture_triggers_kitchen'], ['GROUP', 'furniture_triggers_boiler_room'], ['GROUP', 'furniture_triggers_laundry_oom'], ['GROUP', 'furniture_triggers_garden']];


operateAnimation('STOP', getAnimations(['ALL_OBJECTS']), null, null, 'AUTO', 1,
        function() {}, false);


changeVis(getEntityByName(furniture_triggers, 'OBJECT'), false);

setScreenScale(2);

room_animation_triggers = ['attic_room_trigger', 'bathroom_trigger', 'toilet_trigger', 'bedroom_trigger', 'entrance_trigger', 'living_room_trigger', 'kitchen_trigger', 'boiler_room_trigger', 'laundry_room_trigger', 'garden_trigger'];

zoomed_in = false;

room_animation_duration = 20;

rooms_disapearing_duration = 135;

camera_animation_duration = 60;

registerOnHover('background_sphere', false, function() {
  if (zoomed_in == true) {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);
  }
}, function() {
  setHTMLElemStyle('cursor', 'default', ['BODY'], false);
});

setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 160);
setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 160);
setCameraParam('ORBIT_MIN_VERTICAL_ANGLE', 'camera', 50);
setCameraParam('ORBIT_MAX_VERTICAL_ANGLE', 'camera', 80);
setCameraParam('ORBIT_MIN_HORIZONTAL_ANGLE', 'camera', 30);
setCameraParam('ORBIT_MAX_HORIZONTAL_ANGLE', 'camera', 80);

allow_background_click = false;

setCameraParam('CLIP_END', 'camera', 205);
setCameraParam('CLIP_START', 'camera', 3);

Update_the_text_in_the_Pop_up('radiator_living_room_trigger', ('          <h1 id="popup_object">Radiateur.</h1>' + '\n' +
'              <div id="dividing_line_header"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'            <li>Dépoussiérage et purge.</li>' + '\n' +
'            <li>Entretien et contrôle périodique conformément aux dispositions du bail et à la réglementation en vigueur. Gaz : tous les 2 ans. Autres énergies : tous les ans.</li>' + '\n' +
'            <li>Chauffage suffisant de l\'habitation.</li>' + '\n' +
'          </ul>   ' + '\n' +
'          <div id="dividing_line_2"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'            <li>Tous remplacements.</li>' + '\n' +
'          </ul>   '), 'megamenu_living_room_radiator', 'back_arrow_living_room_popup');
Update_the_text_in_the_Pop_up(['plug_living_room_trigger', 'switch_living_room_trigger', 'ceiling_light_living_room_trigger'], ('          <h1 id="popup_object">Plafonnier, prise de courant, interrupteur.</h1>' + '\n' +
'            <div id="dividing_line_header"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          ' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Remise en état des dégâts suite au placement des luminaires.</li>' + '\n' +
'              <li>Le locataire est tenu de laisser aux points lumineux des fils en attente d\'une longueur de plus ou moins 10 cm. S\'il coupe les fils au raz du plafond ou du mur, il sera tenu au remplacement des fils dans la gaine.</li>' + '\n' +
'              <li>Le locataire doit veiller à entretenir l\'installation électrique et ne pas surcharger celle-ci en tout ou en partie.</li>' + '\n' +
'              <li>Remplacement des ampoules, tubes d\'éclairage, des interrupteurs, soquets et des prises de courant cassés, même suite un usage normal.</li>' + '\n' +
'          </ul>          ' + '\n' +
'' + '\n' +
'          <div id="dividing_line_2"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          ' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'            <li>Tous remplacements des câblages pour tous services sauf si causés par des modifications du locataire.</li>' + '\n' +
'          </ul>   ' + '\n' +
''), 'megamenu_living_room_electricity', 'back_arrow_living_room_popup');
Update_the_text_in_the_Pop_up('window_living_room_trigger', ('          <h1 id="popup_object">Fenètres</h1>' + '\n' +
'              <div id="dividing_line_header"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          ' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Remplacement des vitres brisées par sa faute.</li>' + '\n' +
'              <li>Nettoyage régulier des vitres accessibles.</li>' + '\n' +
'              <li>Remplacement des vitres brisées par sa faute.</li>' + '\n' +
'              <li>Réfection des griffes faites aux vitres et aux châssis.</li>' + '\n' +
'              <li>Maintenir libre écoulement des eaux de condensation des châssis, sous peine de voir sa responsabilité engagée pour les dégâts en résultant (humidité, mérules…).</li>' + '\n' +
'              <li>Réfection des griffes faites aux vitres et aux châssis. En l\'absence de VMC  : aération quotidienne des locaux.</li>' + '\n' +
'          </ul>     ' + '\n' +
'          ' + '\n' +
'          <div id="dividing_line_2"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'            <li>Réparations nécessaires, autres que locatives, et remplacement.</li>' + '\n' +
'          </ul>          ' + '\n' +
''), 'megamenu_living_room_window', 'back_arrow_living_room_popup');
Update_the_text_in_the_Pop_up('fireplace_living_room_trigger', ('          <h1 id="popup_object">Feu ouvert</h1>' + '\n' +
'              <div id="dividing_line_header"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Ramonage annuel, par un professionnel, des conduits d\'évacuation et à tout le moins avant sa sortie des lieux loués.</li>' + '\n' +
'              <li>Entretien et réparation notamment de l’âtre, du contre-cœur, des chambranles et de la tablette de l’âtre.</li>' + '\n' +
'              <li>Nettoyage, cirage éventuel. Le locataire n\'est toutefois pas responsable du brunissement naturel causé par la chaleur ou la fumée résultant d\'un usage normal.</li>' + '\n' +
'          </ul>' + '\n' +
'' + '\n' +
'          <div id="dividing_line_2"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          ' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Réparations nécessaires, autres que locatives, et remplacement.</li>' + '\n' +
'          </ul>' + '\n' +
''), 'megamenu_living_room_fireplace', 'back_arrow_living_room_popup');
Update_the_text_in_the_Pop_up('ventilation_opening_living_room_trigger', ('          <h1 id="popup_object">Bouche de ventilation</h1>' + '\n' +
'              <div id="dividing_line_header"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Nettoyage des bouches qui doivent rester ouvertes en permanence.</li>' + '\n' +
'              <li>Nettoyage et/ou remplacement régulier des filtres.</li>' + '\n' +
'          </ul>' + '\n' +
'' + '\n' +
'          <div id="dividing_line_2"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Réparations nécessaires, autres que locatives, et remplacement.</li>' + '\n' +
'          </ul>'), 'megamenu_living_room_ventilation_opening', 'back_arrow_living_room_popup');
Update_the_text_in_the_Pop_up('radiator_kitchen_trigger', ('          <h1 id="popup_object">Radiateur</h1>' + '\n' +
'              <div id="dividing_line_header"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Dépoussiérage et purge.</li>' + '\n' +
'              <li>Entretien et contrôle périodique conformément aux dispositions du bail et à la réglementation en vigueur. Gaz : tous les 2 ans. Autres énergies : tous les ans.</li>' + '\n' +
'              <li>Chauffage suffisant de l\'habitation.</li>' + '\n' +
'          </ul>' + '\n' +
'          <div id="dividing_line_2"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Tous remplacements.</li>' + '\n' +
'          </ul>' + '\n' +
''), 'megamenu_kitchen_radiator', 'back_arrow_kitchen_popup');
Update_the_text_in_the_Pop_up('ventilation_opening_kitchen_trigger', ('          <h1 id="popup_object">Bouche de ventilation</h1>' + '\n' +
'              <div id="dividing_line_header"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Nettoyage des bouches qui doivent rester ouvertes en permanence.</li>' + '\n' +
'              <li>Nettoyage et/ou remplacement régulier des filtres.</li>' + '\n' +
'          </ul>' + '\n' +
'          <div id="dividing_line_2"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <ul id="popup_paragraph">' + '\n' +
'              <li>Réparations nécessaires, autres que locatives, et remplacement.</li>' + '\n' +
'          </ul>' + '\n' +
''), 'megamenu_kitchen_ventilation_opening', 'back_arrow_kitchen_popup');

eventHTMLElem('click', 'back_arrow_living_room_popup', true, function(event) {
  setHTMLElemStyle('opacity', '0', 'text-block', true);
  registerSetTimeout(0.4, function() {
    setHTMLElemStyle('opacity', '1', 'text-block', true);
    Hide_all_the_pop_up_elements();
    setHTMLElemStyle('display', 'block', 'back_arrow_room_popup', true);
    setHTMLElemStyle('display', 'block', 'living-room-text', true);
  });
});

registerOnClick('electricity_living_room_trigger', false, false, [0,1,2], function() {

  operateAnimation('SET_SPEED', getAnimations(['GROUP', 'switch_living_room']), null, null, 'AUTO', 1.5,
          function() {}, false);


  operateAnimation('PLAY', getAnimations(['GROUP', 'switch_living_room']), 150, 170, 'LoopOnce', 1.5,
          function() {}, false);

      }, function() {
  if (zoomed_in == true && getAnimationFrame('Point.001') == 170) {
    if (isAnimationPlaying(getAnimations(['GROUP', 'switch_living_room']))) {

      operateAnimation('SET_SPEED', getAnimations(['GROUP', 'switch_living_room']), null, null, 'AUTO', 1.5,
              function() {}, true);

          } else {

      operateAnimation('PLAY', getAnimations(['GROUP', 'switch_living_room']), 150, 170, 'LoopOnce', 1.5,
              function() {}, true);

          }
  }
});

eventHTMLElem('click', 'back_arrow_kitchen_popup', true, function(event) {
  setHTMLElemStyle('opacity', '0', 'text-block', true);
  registerSetTimeout(0.4, function() {
    setHTMLElemStyle('opacity', '1', 'text-block', true);
    Hide_all_the_pop_up_elements();
    setHTMLElemStyle('display', 'block', 'back_arrow_room_popup', true);
    setHTMLElemStyle('display', 'block', 'kitchen-text', true);
  });
});

registerOnClick('radiator_living_room_trigger', false, false, [0,1,2], function() {

  operateAnimation('SET_SPEED', getAnimations(['GROUP', 'radiator_living_room']), null, null, 'AUTO', 1,
          function() {}, false);


  operateAnimation('PLAY', getAnimations(['GROUP', 'radiator_living_room']), 150, 170, 'LoopOnce', 0.5,
          function() {}, false);

      }, function() {
  if (zoomed_in == true && getAnimationFrame('Cylinder.013') == 170) {
    if (isAnimationPlaying(getAnimations(['GROUP', 'radiator_living_room']))) {

      operateAnimation('SET_SPEED', getAnimations(['GROUP', 'radiator_living_room']), null, null, 'AUTO', 1,
              function() {}, true);

          } else {

      operateAnimation('PLAY', getAnimations(['GROUP', 'radiator_living_room']), 150, 170, 'LoopOnce', 1,
              function() {}, true);

          }
  }
});

Zoom_to_clicked_room('attic_room_trigger', 'megamenu_attic_room', [animations_except_attic_room, ['GROUP', 'moving_walls']], 'camera_target_attic_room', 'camera_position_attic_room', 'attic_room', null, ['GROUP', 'attic_room'], 'attic-room-text', ['GROUP', 'attic_room']);
Zoom_to_clicked_room('bathroom_trigger', 'megamenu_bathroom', [animations_except_bathroom, ['GROUP', 'moving_walls'], ['GROUP', 'attic_roof_exception']], 'camera_target_bathroom', 'camera_position_bathroom', 'bathroom', null, ['GROUP', 'bathroom'], 'bathroom-text', ['GROUP', 'bathroom']);
Zoom_to_clicked_room('toilet_trigger', 'megamenu_toilet', [animations_except_toilet, ['GROUP', 'attic_roof_exception'], ['GROUP', 'moving_walls']], 'camera_target_toilet', 'camera_position_toilet', 'toilet', null, ['GROUP', 'toilet'], 'toilet-text', ['GROUP', 'toilet']);
Zoom_to_clicked_room('bedroom_trigger', 'megamenu_bedroom', [animations_except_bedroom, ['GROUP', 'attic_roof_exception'], ['GROUP', 'moving_walls']], 'camera_target_bedroom', 'camera_position_bedroom', 'bedroom', null, ['GROUP', 'bedroom'], 'bedroom-text', ['GROUP', 'bedroom']);
Zoom_to_clicked_room('entrance_trigger', 'megamenu_entrance', [['GROUP', 'attic_roof_exception'], animations_except_entrance, ['GROUP', 'moving_walls']], 'camera_target_entrance', 'camera_position_entrance', 'entrance', null, ['GROUP', 'entrance'], 'entrance-text', ['GROUP', 'entrance']);
Zoom_to_clicked_room('living_room_trigger', 'megamenu_living_room', [['GROUP', 'attic_roof_exception'], animations_except_living_room, ['GROUP', 'moving_walls']], 'camera_target_living_room', 'camera_position_living_room', 'living', null, ['GROUP', 'living_room'], 'living-room-text', ['GROUP', 'living_room']);
Zoom_to_clicked_room('kitchen_trigger', 'megamenu_kitchen', [['GROUP', 'attic_roof_exception'], animations_except_kitchen, ['GROUP', 'moving_walls']], 'camera_target_kitchen', 'camera_position_kitchen', 'kitchen', null, ['GROUP', 'kitchen'], 'kitchen-text', ['GROUP', 'kitchen']);
Zoom_to_clicked_room('boiler_room_trigger', 'megamenu_boiler_room', [['GROUP', 'attic_roof_exception'], animations_except_boiler_room, ['GROUP', 'moving_walls']], 'camera_target_boiler_room', 'camera_position_boiler_room', 'boiler', null, ['GROUP', 'boiler_room'], 'boiler-room-text', ['GROUP', 'boiler_room']);
Zoom_to_clicked_room('laundry_room_trigger', 'megamenu_laundry_room', [['GROUP', 'attic_roof_exception'], animations_except_laundry_room, ['GROUP', 'moving_walls']], 'camera_target_laundry_room', 'camera_position_laundry_room', 'laundry_room', null, ['GROUP', 'laundry_room'], 'laundry-room-text', ['GROUP', 'laundry_room']);
Zoom_to_clicked_room('garden_trigger', 'megamenu_garden', [['GROUP', 'attic_roof_exception'], animations_except_garden, ['GROUP', 'moving_walls']], 'camera_target_garden', 'camera_position_garden', 'garden', null, ['GROUP', 'garden'], 'garden-text', ['GROUP', 'garden']);

Hoover_over_room_animation('attic_room_trigger', ['GROUP', 'attic_room'], 'megamenu_attic_room');
Hoover_over_room_animation('bathroom_trigger', ['GROUP', 'bathroom'], 'megamenu_bathroom');
Hoover_over_room_animation('toilet_trigger', ['GROUP', 'toilet'], 'megamenu_toilet');
Hoover_over_room_animation('bedroom_trigger', ['GROUP', 'bedroom'], 'megamenu_bedroom');
Hoover_over_room_animation('entrance_trigger', ['GROUP', 'entrance'], 'megamenu_entrance');
Hoover_over_room_animation('kitchen_trigger', ['GROUP', 'kitchen'], 'megamenu_kitchen');
Hoover_over_room_animation('living_room_trigger', ['GROUP', 'living_room'], 'megamenu_living_room');
Hoover_over_room_animation('boiler_room_trigger', ['GROUP', 'boiler_room'], 'megamenu_boiler_room');
Hoover_over_room_animation('laundry_room_trigger', ['GROUP', 'laundry_room'], 'megamenu_laundry_room');
Hoover_over_room_animation('garden_trigger', ['GROUP', 'garden'], 'megamenu_garden');

Play_zoom_out_animation('attic_room', [animations_except_attic_room, ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('bathroom', [['GROUP', 'attic_roof_exception'], animations_except_bathroom, ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('toilet', [animations_except_toilet, ['GROUP', 'attic_roof_exception'], ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('bedroom', [['GROUP', 'attic_roof_exception'], animations_except_bedroom, ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('entrance', [['GROUP', 'attic_roof_exception'], animations_except_entrance, ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('living', [['GROUP', 'attic_roof_exception'], animations_except_living_room, ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('kitchen', [['GROUP', 'attic_roof_exception'], animations_except_kitchen, ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('boiler', [['GROUP', 'attic_roof_exception'], animations_except_boiler_room, ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('laundry_room', [['GROUP', 'attic_roof_exception'], animations_except_laundry_room, ['GROUP', 'moving_walls']], null);
Play_zoom_out_animation('garden', [['GROUP', 'attic_roof_exception'], animations_except_garden, ['GROUP', 'moving_walls']], null);

room_object_is_selected = false;

room_object_is_selected;

Turn_object_red_when_hovered('wall_covering_kitchen_trigger', ['GROUP', 'wall_covering_kitchen']);
Turn_object_red_when_hovered('radiator_kitchen_trigger', ['GROUP', 'radiator_kitchen']);



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };

/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.5.1
 * Sun, 18 Feb 2024 18:11:39 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables/constants used by puzzles' functions

var LIST_NONE = '<none>';

var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'block', 'start-button', true);
  setHTMLElemStyle('display', 'block', 'start-button-hovered', true);
})();
};

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["Play zoom out animation"] = Play_zoom_out_animation;
this.procedures["Zoom to clicked room"] = Zoom_to_clicked_room;
this.procedures["Update the text in the Pop up"] = Update_the_text_in_the_Pop_up;
this.procedures["set_room_animation_frame_timer"] = set_room_animation_frame_timer;
this.procedures["Hoover over room animation"] = Hoover_over_room_animation;

var animations_except_garden, furniture_triggers, room_animation_triggers, What_is_the_current_camera_, Which_animation_to_play___all_rooms___the_current_one_, Is_there_a_wall___zoom_out_, object_clicked, paragraph_text, Which_room_trigger_, Which_animation_to_play___all_the_rooms___current_one_, Which_room_does_the_camera_look_to_, Empty_to_move_the_camera_to_, Camera_selector_zoom_in, Is_there_a_wall___zoom_in_, Which_room_to_reverse_hover_animation_, room_animation_duration, rooms_disapearing_duration, zoomed_in, camera_animation_duration, Which_room_is_hoovered_, Which_room_to_trigger_hoover_animation_, animations_except_study_room, room_animation_frame, animations_except_living_room, animations_except_boiler_room, current_camera, animations_except_entrance, animations_except_kitchen, animations_except_bedroom, animations_except_bathroom, animations_except_toilet;

// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return obj.type !== 'AmbientLight' &&
           obj.name !== '' &&
           !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
           !obj.isAuxClippingMesh;
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = _pGlob !== undefined;
    objFound = runTime ? _pGlob.objCache[objName] : null;

    if (objFound && objFound.name === objName)
        return objFound;

    if (appInstance.scene) {
        appInstance.scene.traverse(function(obj) {
            if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
                objFound = obj;
                if (runTime) {
                    _pGlob.objCache[objName] = objFound;
                }
            }
        });
    }
    return objFound;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc.filter(function(name) {
        return name;
    });
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}

// getAnimations puzzle
function getAnimations(objSelector) {
    const objNames = retrieveObjectNames(objSelector);

    const animations = [];
    for (let i = 0; i < objNames.length; i++) {
        const objName = objNames[i];
        if (!objName)
            continue;
        // use objName as animName - for now we have one-to-one match
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, objName);
        if (action)
            animations.push(objName);
    }
    return animations;
}

/**
 * Get a scene that contains the root of the given action.
 */
function getSceneByAction(action) {
    var root = action.getRoot();
    var scene = root.type == "Scene" ? root : null;
    root.traverseAncestors(function(ancObj) {
        if (ancObj.type == "Scene") {
            scene = ancObj;
        }
    });
    return scene;
}

/**
 * Get the current scene's framerate.
 */
function getSceneAnimFrameRate(scene) {
    if (scene && 'animFrameRate' in scene.userData) {
        return scene.userData.animFrameRate;
    }
    return 24;
}

function _checkListenersSame(target0, type0, listener0, optionsOrUseCapture0,
        target1, type1, listener1, optionsOrUseCapture1) {
    const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
            ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
    const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
            ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
    return target0 === target1 && type0 === type1 && listener0 === listener1
            && capture0 === capture1;
}

/**
 * Add the specified event listener to the specified target. This function also
 * stores listener data for easier disposing.
 */
function bindListener(target, type, listener, optionsOrUseCapture) {
    const alreadyExists = _pGlob.eventListeners.some(elem => {
        return _checkListenersSame(elem.target, elem.type, elem.listener,
                elem.optionsOrUseCapture, target, type, listener,
                optionsOrUseCapture);
    });

    if (!alreadyExists) {
        target.addEventListener(type, listener, optionsOrUseCapture);
        _pGlob.eventListeners.push({ target, type, listener, optionsOrUseCapture });
    }
}

_pGlob.animMixerCallbacks = [];

var initAnimationMixer = function() {

    function onMixerFinished(e) {
        var cb = _pGlob.animMixerCallbacks;
        var found = [];
        for (var i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (var i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished)) {
            bindListener(appInstance.mixer, 'finished', onMixerFinished);
        }
    };

}();

// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;
        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();
                if (loop && (loop != "AUTO"))
                    action.loop = v3d[loop];
                var scene = getSceneByAction(action);
                var frameRate = getSceneAnimFrameRate(scene);

                action.repetitions = Infinity;

                var timeScale = Math.abs(parseFloat(speed));
                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                var callbacks = _pGlob.animMixerCallbacks;
                var found = false;

                for (var j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            var callbacks = _pGlob.animMixerCallbacks;
            for (var j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            var scene = getSceneByAction(action);
            var frameRate = getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        case 'SET_SPEED':
            var timeScale = parseFloat(speed);
            action.timeScale = rev ? -timeScale : timeScale;
            break;
        }
    }

    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}

// getEntityByName puzzle
function getEntityByName(name, getWhat) {
    switch (getWhat) {
        case 'OBJECT':
        case 'ANIMATION':
        case 'MATERIAL':
            return name;
        case 'GROUP':
            return ['GROUP', name];
    }
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// setCameraParam puzzle
function setCameraParam(type, camSelector, param) {

    const camNames = retrieveObjectNames(camSelector);

    camNames.forEach(function(camName) {
        if (!camName)
            return;

        var cam = getObjectByName(camName);
        if (!cam || !cam.isCamera) return;

        if (!(cam.isPerspectiveCamera || cam.isOrthographicCamera)) {
            console.error('setCameraParam: Incompatible camera type, have to be perspective or orthographic');
            return;
        }

        let isSetOrbitParam = false;
        let isSetFirstpersonParam = false;

        switch (type) {
            case 'ORBIT_MIN_DISTANCE_PERSP':
            case 'ORBIT_MAX_DISTANCE_PERSP':
            case 'ORBIT_MIN_ZOOM_ORTHO':
            case 'ORBIT_MAX_ZOOM_ORTHO':
            case 'ORBIT_MIN_VERTICAL_ANGLE':
            case 'ORBIT_MAX_VERTICAL_ANGLE':
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
            case 'ORBIT_ALLOW_TURNOVER':
                isSetOrbitParam = true;
                break;
            case 'ENABLE_COLLISIONS':
                isSetFirstpersonParam = true;
                break;
        }

        let isSetControlsParam = (['ROTATION_SPEED', 'MOVEMENT_SPEED', 'ALLOW_PANNING', 'ALLOW_ZOOM', 'KEYBOARD_CONTROLS'].includes(type) || isSetOrbitParam || isSetFirstpersonParam);

        if (isSetControlsParam) {
            if (!cam.controls) {
                console.error('setCameraParam: The "' + camName +'" camera has no controller');
                return;
            } else if ((isSetOrbitParam && cam.controls.type != 'ORBIT') ||
                    (isSetFirstpersonParam && cam.controls.type != 'FIRST_PERSON')) {
                console.error('setCameraParam: Incompatible camera controller: ' + cam.controls.type);
                return;
            }
        }

        switch (type) {
            case 'FIELD_OF_VIEW':
                if (cam.isPerspectiveCamera) {
                    cam.fov = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORTHO_SCALE':
                if (cam.isOrthographicCamera) {
                    cam.zoom = param;
                    cam.updateProjectionMatrix();
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ROTATION_SPEED':
                cam.controls.rotateSpeed = param;
                break;
            case 'MOVEMENT_SPEED':
                cam.controls.moveSpeed = param;
                break;
            case 'ALLOW_PANNING':
                cam.controls.enablePan = param;
                break;
            case 'ALLOW_ZOOM':
                cam.controls.enableZoom = param;
                break;
            case 'KEYBOARD_CONTROLS':
                cam.controls.enableKeys = param;
                break;
            case 'ORBIT_MIN_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controls.orbitMinDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MAX_DISTANCE_PERSP':
                if (cam.isPerspectiveCamera) {
                    cam.controls.orbitMaxDistance = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be perspective');
                    return;
                }
                break;
            case 'ORBIT_MIN_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controls.orbitMinZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MAX_ZOOM_ORTHO':
                if (cam.isOrthographicCamera) {
                    cam.controls.orbitMaxZoom = param;
                } else {
                    console.error('setCameraParam: Incompatible camera type, have to be orthographic');
                    return;
                }
                break;
            case 'ORBIT_MIN_VERTICAL_ANGLE':
                cam.controls.orbitMinPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_VERTICAL_ANGLE':
                cam.controls.orbitMaxPolarAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MIN_HORIZONTAL_ANGLE':
                cam.controls.orbitMinAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_MAX_HORIZONTAL_ANGLE':
                cam.controls.orbitMaxAzimuthAngle = v3d.MathUtils.degToRad(param);
                break;
            case 'ORBIT_ALLOW_TURNOVER':
                cam.controls.orbitEnableTurnover = param;
                break;
            case 'ENABLE_COLLISIONS':
                cam.controls.enableCollisions = param;
                break;
            case 'CLIP_START':
                cam.near = param;
                cam.updateProjectionMatrix();
                break;
            case 'CLIP_END':
                cam.far = param;
                cam.updateProjectionMatrix();
                break;
        }

        if (isSetControlsParam)
            appInstance.enableControls();

    });
}

/**
 * Retrieve coordinate system from the loaded scene
 */
function getCoordSystem() {
    var scene = appInstance.scene;

    if (scene && 'coordSystem' in scene.userData) {
        return scene.userData.coordSystem;
    }

    return 'Y_UP_RIGHT';
}


/**
 * Transform coordinates from one space to another
 * Can be used with Vector3 or Euler.
 */
function coordsTransform(coords, from, to, noSignChange) {

    if (from == to)
        return coords;

    var y = coords.y, z = coords.z;

    if (from == 'Z_UP_RIGHT' && to == 'Y_UP_RIGHT') {
        coords.y = z;
        coords.z = noSignChange ? y : -y;
    } else if (from == 'Y_UP_RIGHT' && to == 'Z_UP_RIGHT') {
        coords.y = noSignChange ? z : -z;
        coords.z = y;
    } else {
        console.error('coordsTransform: Unsupported coordinate space');
    }

    return coords;
}


/**
 * Verge3D euler rotation to Blender/Max shortest.
 * 1) Convert from intrinsic rotation (v3d) to extrinsic XYZ (Blender/Max default
 *    order) via reversion: XYZ -> ZYX
 * 2) swizzle ZYX->YZX
 * 3) choose the shortest rotation to resemble Blender's behavior
 */
const eulerV3DToBlenderShortest = function() {

    const eulerTmp = new v3d.Euler();
    const eulerTmp2 = new v3d.Euler();
    const vec3Tmp = new v3d.Vector3();

    return function(euler, dest) {

        const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
        const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();

        const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
        const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();

        dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
        return coordsTransform(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
    }

}();

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = coordsTransform(worldPos, getCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = coordsTransform(worldTarget, getCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart, mouseButtons) {

    var elem = appInstance.renderer.domElement;
    bindListener(elem, eventType, pickListener);

    if (eventType == 'mousedown') {

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        bindListener(elem, touchEventName, pickListener);

    } else if (eventType == 'dblclick') {

        var prevTapTime = 0;

        function doubleTapCallback(event) {

            var now = new Date().getTime();
            var timesince = now - prevTapTime;

            if (timesince < 600 && timesince > 0) {

                pickListener(event);
                prevTapTime = 0;
                return;

            }

            prevTapTime = new Date().getTime();
        }

        var touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
        bindListener(elem, touchEventName, doubleTapCallback);
    }

    var raycaster = new v3d.Raycaster();

    function pickListener(event) {

        // to handle unload in loadScene puzzle
        if (!appInstance.getCamera())
            return;

        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            if (mouseButtons && mouseButtons.indexOf(event.button) == -1)
                return;
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList, false);
        callback(intersects, event);
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered, whenDraggedOver, and raycast puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);
            var objNames = retrieveObjectNames(objSelector);

            if (objectsIncludeObj(objNames, objName)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}

// Describe this function...
function Play_zoom_out_animation(What_is_the_current_camera_, Which_animation_to_play___all_rooms___the_current_one_, Is_there_a_wall___zoom_out_) {
  registerOnClick('background', false, false, [0,1,2], function() {
    if (zoomed_in == true && current_camera == What_is_the_current_camera_) {
      changeVis(getEntityByName(furniture_triggers, 'OBJECT'), false);
      setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 180);
      tweenCamera('camera_position_original', 'camera_target_origin', 0.8, function() {
        zoomed_in = false;
        changeVis(room_animation_triggers, true);
        setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 100);
      }, 0);

      operateAnimation('PLAY', getAnimations(Which_animation_to_play___all_rooms___the_current_one_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
              function() {}, true);


      operateAnimation('PLAY', getAnimations(Is_there_a_wall___zoom_out_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
              function() {}, true);

          }
  }, function() {});
}

// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'CONTAINER' && ids[0] != 'WINDOW' &&
        ids[0] != 'DOCUMENT' && ids[0] != 'BODY' && ids[0] != 'QUERYSELECTOR') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'CONTAINER') {
        if (appInstance !== null) {
            elem = appInstance.container;
        } else if (typeof _initGlob !== 'undefined') {
            // if we are on the initialization stage, we still can have access
            // to the container element
            var id = _initGlob.container;
            if (isParent) {
                elem = parent.document.getElementById(id);
            } else {
                elem = document.getElementById(id);
            }
        }
    } else if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else if (Array.isArray(id) && id[0] == 'QUERYSELECTOR') {
        if (isParent)
            elem = parent.document.querySelector(id);
        else
            elem = document.querySelector(id);
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}

// whenHovered puzzle
initObjectPicking(function(intersects, event) {

    var prevHovered = _pGlob.hoveredObject;
    var currHovered = '';

    // the event might happen before hover registration
    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    // search for closest hovered object

    var lastIntersectIndex = Infinity;
    _pGlob.objHoverInfo.forEach(function(el) {
        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = getPickedObjectName(obj);

            if (objectsIncludeObj(retrieveObjectNames(el.objSelector), objName) && i <= lastIntersectIndex) {
                currHovered = objName;
                lastIntersectIndex = i;
            }
        }
    });

    if (prevHovered == currHovered) return;

    // first - all "out" callbacks, then - all "over"
    _pGlob.objHoverInfo.forEach(function(el) {
        if (objectsIncludeObj(retrieveObjectNames(el.objSelector), prevHovered)) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = prevHovered;
            el.callbacks[1](event);
        }
    });

    _pGlob.objHoverInfo.forEach(function(el) {
        if (objectsIncludeObj(retrieveObjectNames(el.objSelector), currHovered)) {
            // ensure the correct value of the hoveredObject block
            _pGlob.hoveredObject = currHovered;
            el.callbacks[0](event);
        }
    });

    _pGlob.hoveredObject = currHovered;
}, 'mousemove', false);

// whenHovered puzzle
function registerOnHover(objSelector, xRay, cbOver, cbOut) {

    _pGlob.objHoverInfo = _pGlob.objHoverInfo || [];

    _pGlob.objHoverInfo.push({
        objSelector: objSelector,
        callbacks: [cbOver, cbOut],
        xRay: xRay
    });
}

// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}

// Describe this function...
function Update_the_text_in_the_Pop_up(object_clicked, paragraph_text) {
  registerOnHover(object_clicked, false, function() {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);
  }, function() {
    setHTMLElemStyle('cursor', 'default', ['BODY'], false);
  });
  registerOnClick(object_clicked, false, false, [0,1,2], function() {
    setHTMLElemStyle('transform', 'translate(-50%, -50%)', 'text-container-phone', true);
    setHTMLElemAttribute('innerHTML', paragraph_text, 'text-block-phone', true);
    setHTMLElemStyle('transform', 'translate(300%, -50%)', 'text-block', true);
    registerSetTimeout(0.4, function() {
      setHTMLElemAttribute('innerHTML', paragraph_text, 'text-block', true);
      setHTMLElemStyle('transform', 'translate(-50%, -50%)', 'text-block', true);
    });
  }, function() {});
}

// Describe this function...
function Zoom_to_clicked_room(Which_room_trigger_, Which_animation_to_play___all_the_rooms___current_one_, Which_room_does_the_camera_look_to_, Empty_to_move_the_camera_to_, Camera_selector_zoom_in, Is_there_a_wall___zoom_in_, Which_room_to_reverse_hover_animation_) {
  registerOnClick(Which_room_trigger_, false, false, [0,1,2], function() {
    current_camera = Camera_selector_zoom_in;
    if (zoomed_in == false) {
      changeVis(room_animation_triggers, false);
      set_room_animation_frame_timer();
      registerSetTimeout((room_animation_frame / 2 + 0.5) / 24, function() {

        operateAnimation('PLAY', getAnimations(Is_there_a_wall___zoom_in_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
                function() {}, false);


        operateAnimation('PLAY', getAnimations(Which_animation_to_play___all_the_rooms___current_one_), 40, rooms_disapearing_duration, 'LoopOnce', 6,
                function() {}, false);

            tweenCamera(Empty_to_move_the_camera_to_, Which_room_does_the_camera_look_to_, 0.8, function() {
          zoomed_in = true;
          changeVis(getEntityByName(furniture_triggers, 'OBJECT'), true);
        }, 0);
        setCameraParam('ORBIT_MIN_DISTANCE_PERSP', 'camera', 50);
        setCameraParam('ORBIT_MAX_DISTANCE_PERSP', 'camera', 100);
      });
    }
  }, function() {});
}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        bindListener(elem, eventType, callback);
    }
}

// getAnimationFrame puzzle
function getAnimationFrame(animName) {
    if (!animName)
        return;
    var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
    if (action) {
        var scene = getSceneByAction(action);
        var frameRate = getSceneAnimFrameRate(scene);
        return action.time * frameRate;
    } else {
        return;
    }
}

function listsGetSortCompare(type, direction) {
  var compareFuncs = {
    'NUMERIC': function(a, b) {
        return Number(a) - Number(b); },
    'TEXT': function(a, b) {
        return a.toString() > b.toString() ? 1 : -1; },
    'IGNORE_CASE': function(a, b) {
        return a.toString().toLowerCase() > b.toString().toLowerCase() ? 1 : -1; },
  };
  var compare = compareFuncs[type];
  return function(a, b) { return compare(a, b) * direction; };
}

// Describe this function...
function set_room_animation_frame_timer() {
  room_animation_frame = [getAnimationFrame('toilet_trigger'), getAnimationFrame('bedroom_trigger'), getAnimationFrame('bathroom_trigger'), getAnimationFrame('entrance_trigger'), getAnimationFrame('boiler_room_trigger'), getAnimationFrame('living_room_trigger'), getAnimationFrame('kitchen_trigger')].slice().sort(listsGetSortCompare("NUMERIC", -1))[0];
}

// outline puzzle
function outline(objSelector, doWhat) {
    var objNames = retrieveObjectNames(objSelector);

    if (!appInstance.postprocessing || !appInstance.postprocessing.outlinePass)
        return;
    var outlineArray = appInstance.postprocessing.outlinePass.selectedObjects;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        if (doWhat == "ENABLE") {
            if (outlineArray.indexOf(obj) == -1)
                outlineArray.push(obj);
        } else {
            var index = outlineArray.indexOf(obj);
            if (index > -1)
                outlineArray.splice(index, 1);
        }
    }
}

// isAnimationPlaying puzzle
function isAnimationPlaying(animations) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];
    for (let i = 0; i < animations.length; i++) {
        const animName = animations[i];
        if (!animName)
            continue;
        const action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (action && action.isRunning())
            return true;
    }
    return false;
}

// Describe this function...
function Hoover_over_room_animation(Which_room_is_hoovered_, Which_room_to_trigger_hoover_animation_) {
  registerOnHover(Which_room_is_hoovered_, false, function() {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);

    operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
            function() {}, false);


    operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
            function() {}, false);

        }, function() {
    setHTMLElemStyle('cursor', 'default', ['BODY'], false);
    if (isAnimationPlaying(getAnimations(Which_room_to_trigger_hoover_animation_))) {

      operateAnimation('SET_SPEED', getAnimations(Which_room_to_trigger_hoover_animation_), null, null, 'AUTO', 2,
              function() {}, true);

          } else {

      operateAnimation('PLAY', getAnimations(Which_room_to_trigger_hoover_animation_), 0, room_animation_duration, 'LoopOnce', 2,
              function() {}, true);

          }
  });
}


animations_except_garden = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'living_room'], ['GROUP', 'toilet'], ['GROUP', 'entrance'], ['GROUP', 'study_room']];
animations_except_study_room = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'living_room'], ['GROUP', 'toilet'], ['GROUP', 'entrance'], ['GROUP', 'garden']];
animations_except_boiler_room = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'living_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_kitchen = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'living_room'], ['GROUP', 'study_room'], ['GROUP', 'garden'], ['GROUP', 'entrance'], ['GROUP', 'toilet']];
animations_except_bedroom = [['GROUP', 'bathroom'], ['GROUP', 'living_room'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_bathroom = [['GROUP', 'living_room'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_toilet = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'living_room'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_living_room = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'entrance'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];
animations_except_entrance = [['GROUP', 'bathroom'], ['GROUP', 'bedroom'], ['GROUP', 'boiler_room'], ['GROUP', 'kitchen'], ['GROUP', 'living_room'], ['GROUP', 'toilet'], ['GROUP', 'garden'], ['GROUP', 'study_room']];


operateAnimation('STOP', getAnimations(['ALL_OBJECTS']), null, null, 'AUTO', 1,
        function() {}, false);


furniture_triggers = [['GROUP', 'furniture_triggers_living_room'], null, null];

changeVis(getEntityByName(furniture_triggers, 'OBJECT'), false);

room_animation_triggers = ['toilet_trigger', 'bedroom_trigger', 'kitchen_trigger', 'bathroom_trigger', 'entrance_trigger', 'boiler_room_trigger', 'living_room_trigger', 'garden_trigger', 'study_room_trigger'];

room_animation_duration = 20;

rooms_disapearing_duration = 135;

eventHTMLElem('click', 'popup-cross', true, function(event) {
  setHTMLElemStyle('transform', 'translate(300%, -50%)', 'text-container-phone', true);
});

zoomed_in = false;

camera_animation_duration = 60;

registerOnHover('background', false, function() {
  if (zoomed_in == true) {
    setHTMLElemStyle('cursor', 'pointer', ['BODY'], false);
  }
}, function() {
  setHTMLElemStyle('cursor', 'default', ['BODY'], false);
});

registerOnHover('cupboard_trigger', false, function() {
  outline(['GROUP', 'cuboard'], 'ENABLE');
}, function() {
  outline(['GROUP', 'cuboard'], 'DISABLE');
});

Update_the_text_in_the_Pop_up('radiator_living_room_trigger', ('          <h1 id="popup_room">Séjour</h1>' + '\n' +
'          <h1 id="popup_object">Fenètres</h1>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Remplacement des vitres brisées par sa faute.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Nettoyage régulier des vitres accessibles.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Remplacement des vitres brisées par sa faute.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Réfection des griffes faites aux vitres et aux châssis.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Maintenir libre écoulement des eaux de condensation des châssis, sous peine de voir sa responsabilité engagée pour les dégâts en résultant (humidité, mérules…).</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Réfection des griffes faites aux vitres et aux châssis. En l\'absence de VMC  : aération quotidienne des locaux.</p>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Réparations nécessaires, autres que locatives, et remplacement.</p>'));
Update_the_text_in_the_Pop_up('electricity_living_room_trigger', ('          <h1 id="popup_room">Séjour</h1>' + '\n' +
'          <h1 id="popup_object">Plafonnier, prise de courant, interrupteur.</h1>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Locataire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Remise en état des dégâts suite au placement des luminaires. </p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Le locataire est tenu de laisser aux points lumineux des fils en attente d\'une longueur de plus ou moins 10 cm. S\'il coupe les fils au raz du plafond ou du mur, il sera tenu au remplacement des fils dans la gaine.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Le locataire doit veiller à entretenir l\'installation électrique et ne pas surcharger celle-ci en tout ou en partie.</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Remplacement des ampoules, tubes d\'éclairage, des interrupteurs, soquets et des prises de courant cassés, même suite un usage normal.</p>' + '\n' +
'          <div id="dividing_line"></div>' + '\n' +
'          <p id="popup_locataire">Propriétaire</p>' + '\n' +
'          <p id="popup_paragraph"><span id="color_overwrite">•</span> Tous remplacements des câblages pour tous services sauf si causés par des modifications du locataire. </p>'));

Play_zoom_out_animation('living', animations_except_living_room, null);
Play_zoom_out_animation('entrance', animations_except_entrance, 'trigger_entrance_wall_animation');
Play_zoom_out_animation('kitchen', animations_except_kitchen, 'trigger_kitchen_wall_animation');
Play_zoom_out_animation('bathroom', animations_except_bathroom, null);
Play_zoom_out_animation('boiler', animations_except_boiler_room, null);
Play_zoom_out_animation('bedroom', animations_except_bedroom, null);
Play_zoom_out_animation('toilet', animations_except_toilet, null);
Play_zoom_out_animation('garden', animations_except_garden, null);
Play_zoom_out_animation('study_room', animations_except_study_room, 'trigger_study_room_animation');

registerOnClick('lamp_trigger', false, false, [0,1,2], function() {}, function() {});

outline('Cylinder', 'ENABLE');

Zoom_to_clicked_room('living_room_trigger', animations_except_living_room, 'camera_target_living_room', 'camera_position_living_room', 'living', null, ['GROUP', 'living_room']);
Zoom_to_clicked_room('entrance_trigger', animations_except_entrance, 'camera_target_entrance', 'camera_position_entrance', 'entrance', 'trigger_entrance_wall_animation', ['GROUP', 'entrance']);
Zoom_to_clicked_room('kitchen_trigger', animations_except_kitchen, 'camera_target_kitchen', 'camera_position_kitchen', 'kitchen', 'trigger_kitchen_wall_animation', ['GROUP', 'kitchen']);
Zoom_to_clicked_room('bathroom_trigger', animations_except_bathroom, 'camera_target_bathroom', 'camera_position_bathroom', 'bathroom', null, ['GROUP', 'bathroom']);
Zoom_to_clicked_room('boiler_room_trigger', animations_except_boiler_room, 'camera_target_boiler_room', 'camera_position_boiler_room', 'boiler', null, ['GROUP', 'boiler_room']);
Zoom_to_clicked_room('bedroom_trigger', animations_except_bedroom, 'camera_target_bedroom', 'camera_position_bedroom', 'bedroom', null, ['GROUP', 'bedroom']);
Zoom_to_clicked_room('toilet_trigger', animations_except_toilet, 'camera_target_toilet', 'camera_position_toilet', 'toilet', null, ['GROUP', 'toilet']);
Zoom_to_clicked_room('garden_trigger', animations_except_garden, 'camera_target_garden', 'camera_position_garden', 'garden', null, ['GROUP', 'garden']);
Zoom_to_clicked_room('study_room_trigger', animations_except_study_room, 'camera_target_study_room', 'camera_position_study_room', 'study_room', 'trigger_study_room_animation', ['GROUP', 'study_room']);

registerOnClick('lamp_trigger', false, false, [0,1,2], function() {

  operateAnimation('SET_SPEED', getAnimations(['GROUP', 'light_entrance']), null, null, 'AUTO', 1,
          function() {}, false);


  operateAnimation('PLAY', getAnimations('Point'), 150, 170, 'LoopOnce', 2,
          function() {}, false);

      }, function() {
  if (zoomed_in == true && getAnimationFrame('Point') == 170) {
    if (isAnimationPlaying(getAnimations('Point'))) {

      operateAnimation('SET_SPEED', getAnimations('Point'), null, null, 'AUTO', 1,
              function() {}, true);

          } else {

      operateAnimation('PLAY', getAnimations('Point'), 150, 170, 'LoopOnce', 2,
              function() {}, true);

          }
  }
});

Hoover_over_room_animation('entrance_trigger', ['GROUP', 'entrance']);
Hoover_over_room_animation('kitchen_trigger', ['GROUP', 'kitchen']);
Hoover_over_room_animation('living_room_trigger', ['GROUP', 'living_room']);
Hoover_over_room_animation('bathroom_trigger', ['GROUP', 'bathroom']);
Hoover_over_room_animation('toilet_trigger', ['GROUP', 'toilet']);
Hoover_over_room_animation('boiler_room_trigger', ['GROUP', 'boiler_room']);
Hoover_over_room_animation('bedroom_trigger', ['GROUP', 'bedroom']);
Hoover_over_room_animation('garden_trigger', ['GROUP', 'garden']);
Hoover_over_room_animation('study_room_trigger', ['GROUP', 'study_room']);

if (zoomed_in == true) {
  Update_the_text_in_the_Pop_up('background', ('          <div class="popup-cross" id="popup-cross"></div>' + '\n' +
  '          <h1 id="popup_room">Maquette PLE</h1>' + '\n' +
  '          <h1 id="popup_object">Interactive et explorable</h1>' + '\n' +
  '          <div id="dividing_line"></div>' + '\n' +
  '          <p id="popup_locataire">Navigation</p>' + '\n' +
  '          <p id="popup_paragraph"><span id="color_overwrite">•</span> Utiliser la souris pour tourner autour de la maquette.</p>' + '\n' +
  '          <p id="popup_paragraph"><span id="color_overwrite">•</span> Clickez sur une pièce pour zoomer.</p>' + '\n' +
  '          <p id="popup_paragraph"><span id="color_overwrite">•</span> Sélectionner un objet</p>' + '\n' +
  '          <div id="dividing_line"></div>' + '\n' +
  '          <p id="popup_locataire">Information</p>' + '\n' +
  '          <p id="popup_paragraph"><span id="color_overwrite">•</span> Une fois l\'objet cliqué, des informations s\'affichent.</p>'));
}

registerOnClick('cupboard_trigger', false, false, [0,1,2], function() {

  operateAnimation('SET_SPEED', getAnimations(['GROUP', 'cuboard']), null, null, 'AUTO', 1,
          function() {}, false);


  operateAnimation('PLAY', getAnimations(['GROUP', 'cuboard']), 150, 170, 'LoopOnce', 1,
          function() {}, false);

      }, function() {
  if (zoomed_in == true && getAnimationFrame('cupboard_trigger') == 170) {
    if (isAnimationPlaying(getAnimations(['GROUP', 'cuboard']))) {

      operateAnimation('SET_SPEED', getAnimations(['GROUP', 'cuboard']), null, null, 'AUTO', 1,
              function() {}, true);

          } else {

      operateAnimation('PLAY', getAnimations(['GROUP', 'cuboard']), 150, 170, 'LoopOnce', 1,
              function() {}, true);

          }
  }
});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
